type ActivityData {
  dailyActivity: [DailyActivity!]
  hourlyActivity: [HourlyActivity!]
  tokenUsage: TokenUsageStats
  dailyModelTokens: [DailyModelTokens!]
  modelUsage: [ModelUsageStats!]
  totalSessions: Int
  totalMessages: Int
  streakDays: Int
  totalActiveDays: Int
  firstSessionDate: String
}

type AgentTask {
  id: String
}

type AssistantMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]!
  model: String
  stopReason: String
  isToolOnly: Boolean
  hasThinking: Boolean
  thinkingCount: Int
  hasToolUse: Boolean
  toolUseCount: Int
  inputTokens: Int
  outputTokens: Int
  cachedTokens: Int
}

type CommandUserMessage implements Message & UserMessage {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  sentimentAnalysis: SentimentAnalysis
  commandName: String
}

type CompactionStats {
  totalCompactions: Int
  sessionsWithCompactions: Int
  sessionsWithoutCompactions: Int
  avgCompactionsPerSession: Float
  autoCompactCount: Int
  manualCompactCount: Int
  continuationCount: Int
}

type ConfigDir {
  id: ID!
  path: String!
  name: String
  isDefault: Boolean!
  registeredAt: String!
  lastIndexedAt: String
  sessionCount: Int
}

type ConfigDirCostBreakdown {
  configDirId: String
  configDirName: String
  estimatedCostUsd: Float
  isEstimated: Boolean
  cacheSavingsUsd: Float
  totalSessions: Int
  totalMessages: Int
  modelCount: Int
  costPerSession: Float
  cacheHitRate: Float
  potentialSavingsUsd: Float
  costUtilizationPercent: Float
  dailyCostTrend: [DailyCost!]
  weeklyCostTrend: [WeeklyCost!]
  subscriptionComparisons: [SubscriptionComparison!]
  breakEvenDailySpend: Float
  topSessionsByCost: [SessionCost!]
}

interface ContentBlock {
  type: ContentBlockType!
}

enum ContentBlockType {
  TEXT
  THINKING
  TOOL_USE
  TOOL_RESULT
  IMAGE
}

type CoordinatorStatus {
  version: String!
  needsRestart: Boolean!
}

type CostAnalysis {
  estimatedCostUsd: Float
  isEstimated: Boolean
  cacheHitRate: Float
  cacheSavingsUsd: Float
  costPerSession: Float
  costPerCompletedTask: Float
  maxSubscriptionCostUsd: Float
  costUtilizationPercent: Float
  breakEvenDailySpend: Float
  billingType: String
  dailyCostTrend: [DailyCost!]
  weeklyCostTrend: [WeeklyCost!]
  topSessionsByCost: [SessionCost!]
  potentialSavingsUsd: Float
  subscriptionComparisons: [SubscriptionComparison!]
  configDirBreakdowns: [ConfigDirCostBreakdown!]
}

type DailyActivity {
  date: String
  sessionCount: Int
  messageCount: Int
  inputTokens: Int
  outputTokens: Int
  cachedTokens: Int
  linesAdded: Int
  linesRemoved: Int
  filesChanged: Int
}

type DailyCost {
  date: String
  costUsd: Float
  sessionCount: Int
}

type DailyModelTokens {
  date: String
  models: [ModelTokenEntry!]
  totalTokens: Int
}

type DashboardAnalytics {
  topSessions: [SessionEffectiveness!]
  bottomSessions: [SessionEffectiveness!]
  compactionStats: CompactionStats
  costAnalysis: CostAnalysis
  hookHealth: [HookHealthStats!]
  subagentUsage: [SubagentUsageStats!]
  toolUsage: [ToolUsageStats!]
}

type ExposedToolCallMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  tool: String
  server: String
  callId: String
  prefixedName: String
  input: String
  result: ExposedToolResult
}

type ExposedToolResult {
  output: String
  error: String
  durationMs: Int
}

type ExposedToolResultMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  tool: String
  prefixedName: String
  callId: String
  success: Boolean
  durationMs: Int
  output: String
  error: String
}

type FileChange {
  id: String
  filePath: String
  action: FileChangeAction
  toolName: String
  recordedAt: String
  sessionId: String
  isValidated: Boolean
  fileHashBefore: String
  fileHashAfter: String
  validations: [FileValidation!]
  missingValidations: [FileValidation!]
}

enum FileChangeAction {
  created
  modified
  deleted
}

type FileChangeConnection {
  edges: [FileChangeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FileChangeEdge {
  node: FileChange!
  cursor: String!
}

type FileHistorySnapshotMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  messageId: String
  fileCount: Int
  isSnapshotUpdate: Boolean
  snapshotTimestamp: String
}

type FileValidation {
  id: String
  pluginName: String
  hookName: String
  validatedAt: String
  directory: String
}

type FrustrationSummary {
  totalAnalyzed: Int
  moderateCount: Int
  highCount: Int
  overallLevel: String
  averageScore: Float
  peakScore: Float
  topSignals: [String!]
}

type HookCheckStateMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  hookType: String
  hooksCount: Int
  fingerprint: String
}

type HookDatetimeMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  datetime: String
  plugin: String
  durationMs: Int
}

type HookExecution {
  id: ID!
  hookType: String!
  hookName: String!
  hookSource: String
  directory: String
  durationMs: Int!
  exitCode: Int!
  passed: Boolean!
  output: String
  error: String
  command: String
  executedAt: String!
  status: String
}

type HookExecutionConnection {
  edges: [HookExecutionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type HookExecutionEdge {
  node: HookExecution!
  cursor: String!
}

type HookFileChangeMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  filePath: String
  action: String
  changeToolName: String
  recordedSessionId: String
}

type HookHealthStats {
  hookName: String
  totalRuns: Int
  passCount: Int
  failCount: Int
  passRate: Float
  avgDurationMs: Float
}

type HookReferenceMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  filePath: String
  plugin: String
  reason: String
  success: Boolean
  durationMs: Int
}

type HookResult {
  success: Boolean
  output: String
  error: String
  durationMs: Int
  exitCode: Int
  cached: Boolean
}

type HookResultAddedPayload {
  sessionId: String!
  hookRunId: String!
  pluginName: String!
  hookName: String!
  success: Boolean!
  durationMs: Int!
}

type HookResultMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  hook: String
  directory: String
  hookName: String
  plugin: String
  success: Boolean
  durationMs: Int
  exitCode: Int
  output: String
  error: String
  cached: Boolean
}

type HookRunMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  hookName: String
  hook: String
  plugin: String
  hookType: String
  directory: String
  hookRunId: String
  cached: Boolean
  result: HookResult
}

type HookScriptMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  command: String
  plugin: String
  success: Boolean
  durationMs: Int
  exitCode: Int
  output: String
}

type HookStats {
  totalHooks: Int
  passedHooks: Int
  failedHooks: Int
  totalDurationMs: Int
  passRate: Float
  byHookType: [HookTypeStat!]
}

type HookTypeStat {
  hookType: String
  total: Int
  passed: Int
}

type HookValidationCacheMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  hook: String
  plugin: String
  directory: String
  fileCount: Int
}

type HookValidationMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  hook: String
  plugin: String
  directory: String
  success: Boolean
  cached: Boolean
  durationMs: Int
  exitCode: Int
  output: String
  error: String
}

type HourlyActivity {
  hour: Int
  sessionCount: Int
  messageCount: Int
}

type ImageBlock implements ContentBlock {
  type: ContentBlockType!
  mediaType: String!
  dataUrl: String!
}

type InterruptUserMessage implements Message & UserMessage {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  sentimentAnalysis: SentimentAnalysis
}

type McpToolCallMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  tool: String
  server: String
  serverName: String
  callId: String
  prefixedName: String
  input: String
  result: McpToolResult
}

type McpToolResult {
  output: String
  error: String
  durationMs: Int
}

type McpToolResultMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  tool: String
  server: String
  prefixedName: String
  callId: String
  success: Boolean
  durationMs: Int
  output: String
  error: String
}

type MemoryLearnMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  scope: String
  append: Boolean
  paths: [String!]
}

type MemoryQueryMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  question: String
  route: String
  resultCount: Int
  durationMs: Int
}

interface Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
}

type MessageConnection {
  edges: [MessageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MessageEdge {
  node: Message!
  cursor: String!
}

type MessageSearchResult {
  messageId: String
  messageIndex: Int
  preview: String
  matchContext: String
}

type MetaUserMessage implements Message & UserMessage {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  sentimentAnalysis: SentimentAnalysis
}

type MetricsData {
  totalTasks: Int
  completedTasks: Int
  successRate: Float
  averageConfidence: Float
  averageDuration: Float
  calibrationScore: Float
  significantFrustrations: Int
  significantFrustrationRate: Float
  tasksByType: [TaskTypeCount!]
  tasksByOutcome: [TaskOutcomeCount!]
}

enum MetricsPeriod {
  DAY
  WEEK
  MONTH
}

type ModelTokenEntry {
  model: String
  displayName: String
  tokens: Int
}

type ModelUsageStats {
  model: String
  displayName: String
  inputTokens: Int
  outputTokens: Int
  cacheReadTokens: Int
  cacheCreationTokens: Int
  totalTokens: Int
  costUsd: Float
}

type MutationRoot {
  togglePlugin(name: String!, enabled: Boolean!): Boolean!
  removePlugin(name: String!): Boolean!
  registerConfigDir(path: String!, name: String): Boolean!
  unregisterConfigDir(path: String!): Boolean!
}

type NativeTask {
  id: ID!
  subject: String!
  description: String
  status: String!
  activeForm: String
  owner: String
  blocks: [String!]
  blockedBy: [String!]
  createdAt: String!
  updatedAt: String!
  completedAt: String
}

type NodeUpdatedPayload {
  id: String!
  typename: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Plugin {
  id: ID!
  name: String
  enabled: Boolean
  scope: PluginScope
  marketplace: String
  category: String
}

type PluginCategory {
  category: String
  count: Int
}

enum PluginScope {
  USER
  PROJECT
  LOCAL
}

type PluginStats {
  totalPlugins: Int
  userPlugins: Int
  projectPlugins: Int
  localPlugins: Int
  enabledPlugins: Int
}

type Project {
  id: ID!
  slug: String!
  path: String!
  name: String!
  repoId: String
  relativePath: String
  isWorktree: Boolean!
  createdAt: String!
  updatedAt: String!
}

type ProjectAddedPayload {
  projectId: String!
  parentId: String
}

type Query {
  node(id: ID!): String
  projects(first: Int): [Project!]!
  project(id: String!): Project
  repos(first: Int): [Repo!]!
  repo(id: String!): Repo
  configDirs: [ConfigDir!]!
  session(id: String!): Session
  sessions(
    first: Int,
    after: String,
    last: Int,
    before: String,
    projectId: String,
    worktreeName: String
  ): SessionConnection!
  coordinatorStatus(clientVersion: String): CoordinatorStatus!
  metrics(period: MetricsPeriod): MetricsData
  plugins(scope: PluginScope): [Plugin!]
  pluginStats: PluginStats
  pluginCategories: [PluginCategory!]
  activity(days: Int): ActivityData
  dashboardAnalytics(days: Int, subscriptionTier: Int): DashboardAnalytics
}

type QueueOperationMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  operation: String
  queueSessionId: String
}

type RegularUserMessage implements Message & UserMessage {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  sentimentAnalysis: SentimentAnalysis
}

type Repo {
  id: ID!
  remote: String!
  name: String!
  defaultBranch: String
  createdAt: String!
  updatedAt: String!
}

type RepoAddedPayload {
  repoId: String!
}

type SentimentAnalysis {
  id: ID!
  sentimentScore: Float
  sentimentLevel: String
  frustrationScore: Float
  frustrationLevel: String
  signals: [String!]
}

type SentimentAnalysisMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  analyzedMessageId: String
  messageId: String
  sentimentScore: Float
  sentimentLevel: String
  frustrationScore: Float
  frustrationLevel: String
  signals: [String!]
}

type Session {
  id: ID!
  sessionId: String!
  slug: String
  name: String!
  date: String!
  projectName: String!
  projectPath: String!
  projectId: String
  projectSlug: String
  worktreeName: String
  summary: String
  messageCount: Int!
  startedAt: String
  updatedAt: String
  gitBranch: String
  version: String
  status: String
  sourceConfigDir: String
  messages(first: Int, after: String, last: Int, before: String): MessageConnection!
  nativeTasks: [NativeTask!]!
  orgId: String
  owner: User
  project: Project
  currentTodo: Todo
  currentTask: Task
  agentTaskIds: [String!]
  tasks(first: Int, after: String, last: Int, before: String): TaskConnection
  activeTasks(first: Int, after: String, last: Int, before: String): TaskConnection
  todos(first: Int, after: String, last: Int, before: String): TodoConnection
  activeTodos(first: Int, after: String, last: Int, before: String): TodoConnection
  todoCounts: TodoCounts
  fileChanges(first: Int, after: String, last: Int, before: String): FileChangeConnection
  fileChangeCount: Int
  hookExecutions(first: Int, after: String, last: Int, before: String): HookExecutionConnection
  hookStats: HookStats
  frustrationSummary: FrustrationSummary
  searchMessages(query: String!, limit: Int): [MessageSearchResult!]
  toolResults: [ToolResultBlock!]
}

type SessionAddedPayload {
  sessionId: String!
  parentId: String
}

type SessionConnection {
  edges: [SessionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SessionCost {
  sessionId: String
  slug: String
  costUsd: Float
  inputTokens: Int
  outputTokens: Int
  cacheReadTokens: Int
  messageCount: Int
  startedAt: String
}

type SessionEdge {
  node: Session!
  cursor: String!
}

type SessionEffectiveness {
  sessionId: String
  slug: String
  summary: String
  startedAt: String
  score: Float
  sentimentTrend: String
  avgSentimentScore: Float
  turnCount: Int
  taskCompletionRate: Float
  compactionCount: Int
  focusScore: Float
}

type SessionFilesChangedPayload {
  sessionId: String!
  fileCount: Int!
  toolName: String!
}

type SessionHooksChangedPayload {
  sessionId: String!
  pluginName: String!
  hookName: String!
  eventType: String!
}

type SessionMessageAddedPayload {
  sessionId: String!
  messageIndex: Int!
}

type SessionTodosChangedPayload {
  sessionId: String!
  todoCount: Int!
  inProgressCount: Int!
  completedCount: Int!
}

type SubagentUsageStats {
  subagentType: String
  count: Int
}

type SubscriptionComparison {
  tierName: String
  monthlyCostUsd: Float
  apiCreditCostUsd: Float
  savingsUsd: Float
  savingsPercent: Float
  recommendation: String
}

type SubscriptionRoot {
  nodeUpdated(id: ID!): NodeUpdatedPayload!
  sessionMessageAdded(sessionId: ID!): SessionMessageAddedPayload!
  toolResultAdded(callId: String!): ToolResultAddedPayload!
  hookResultAdded(hookRunId: String!): HookResultAddedPayload!
  sessionTodosChanged(sessionId: ID!): SessionTodosChangedPayload!
  sessionFilesChanged(sessionId: ID!): SessionFilesChangedPayload!
  sessionHooksChanged(sessionId: ID!): SessionHooksChangedPayload!
  sessionAdded(parentId: ID): SessionAddedPayload!
  repoAdded: RepoAddedPayload!
  projectAdded(parentId: ID): ProjectAddedPayload!
}

type SummaryMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  isCompactSummary: Boolean
}

type SystemMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  isMeta: Boolean
  level: String
  subtype: String
}

type Task {
  id: ID!
  taskId: String!
  description: String!
  taskType: String!
  type: TaskType
  status: TaskStatus!
  outcome: String
  confidence: Float
  notes: String
  filesModified: [String!]
  testsAdded: Int
  startedAt: String!
  completedAt: String
  durationSeconds: Int
}

type TaskConnection {
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TaskEdge {
  node: Task!
  cursor: String!
}

enum TaskOutcome {
  SUCCESS
  PARTIAL
  FAILURE
}

type TaskOutcomeCount {
  outcome: TaskOutcome
  count: Int
}

enum TaskStatus {
  ACTIVE
  COMPLETED
  FAILED
}

enum TaskType {
  FIX
  IMPLEMENTATION
  REFACTOR
  RESEARCH
}

type TaskTypeCount {
  type: TaskType
  count: Int
}

type TextBlock implements ContentBlock {
  type: ContentBlockType!
  text: String!
}

type ThinkingBlock implements ContentBlock {
  type: ContentBlockType!
  thinking: String!
  preview: String!
  signature: String
}

type Todo {
  id: ID
  content: String
  status: TodoStatus
  activeForm: String
}

type TodoConnection {
  edges: [TodoEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TodoCounts {
  total: Int
  pending: Int
  inProgress: Int
  completed: Int
}

type TodoEdge {
  node: Todo!
  cursor: String!
}

enum TodoStatus {
  pending
  in_progress
  completed
}

type TokenUsageStats {
  totalInputTokens: Int
  totalOutputTokens: Int
  totalCachedTokens: Int
  totalTokens: Int
  estimatedCostUsd: Float
  messageCount: Int
  sessionCount: Int
}

enum ToolCategory {
  FILE
  SEARCH
  SHELL
  TASK
  WEB
  MCP
  OTHER
}

type ToolResultAddedPayload {
  sessionId: String!
  callId: String!
  type: String!
  success: Boolean!
  durationMs: Int!
}

type ToolResultBlock implements ContentBlock {
  type: ContentBlockType!
  toolCallId: String!
  content: String!
  isError: Boolean!
  isLong: Boolean!
  preview: String!
  hasImage: Boolean!
}

type ToolResultUserMessage implements Message & UserMessage {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  sentimentAnalysis: SentimentAnalysis
  toolResultCount: Int
}

type ToolUsageStats {
  toolName: String
  count: Int
}

type ToolUseBlock implements ContentBlock {
  type: ContentBlockType!
  toolCallId: String!
  name: String!
  input: String!
  category: ToolCategory!
  icon: String!
  displayName: String!
  color: String!
  sessionId: String
  agentTaskId: String
  result: ToolResultBlock
  agentTask: AgentTask
}

type UnknownEventMessage implements Message {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  eventType: String
  messageType: String
}

type User {
  id: ID!
  name: String
  email: String
  avatarUrl: String
}

interface UserMessage {
  id: ID!
  uuid: String!
  timestamp: String!
  rawJson: String
  agentId: String
  parentId: String
  searchText: String
  content: String
  contentBlocks: [ContentBlock!]
  sentimentAnalysis: SentimentAnalysis
}

type WeeklyCost {
  weekStart: String
  weekLabel: String
  costUsd: Float
  sessionCount: Int
  avgDailyCost: Float
}

