/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Lock file contents */
export interface LockInfo {
  /** Process ID holding the lock */
  pid: number;
  /** Timestamp when lock was acquired (Unix epoch seconds) */
  acquiredAt: number;
  /** Last heartbeat timestamp (Unix epoch seconds) */
  heartbeatAt: number;
  /** Whether this process is the coordinator */
  isCoordinator: boolean;
}
/** Coordinator status */
export interface CoordinatorStatus {
  /** Whether this process is the active coordinator */
  isCoordinator: boolean;
  /** Whether a coordinator is running (possibly another process) */
  coordinatorRunning: boolean;
  /** Lock info if available */
  lockInfo?: LockInfo;
}
/** Input for enqueuing an async hook */
export interface AsyncHookQueueInputNative {
  sessionId: string;
  cwd: string;
  plugin: string;
  hookName: string;
  filePaths: Array<string>;
  command: string;
}
/** Output for async hook queue entry */
export interface AsyncHookQueueEntry {
  id: string;
  sessionId: string;
  cwd: string;
  plugin: string;
  hookName: string;
  filePaths: Array<string>;
  command: string;
  status: string;
  createdAt: string;
}
/** A document record for FTS indexing */
export interface FtsDocument {
  /** Unique identifier for the document */
  id: string;
  /** The text content to index */
  content: string;
  /** Optional metadata as JSON string */
  metadata?: string;
}
/** A search result from FTS query */
export interface FtsSearchResult {
  /** Document ID */
  id: string;
  /** The matched content */
  content: string;
  /** Optional metadata as JSON string */
  metadata?: string;
  /** BM25 relevance score */
  score: number;
}
/** A search result from vector query */
export interface VectorSearchResult {
  /** Document ID */
  id: string;
  /** The matched content */
  content: string;
  /** Optional metadata as JSON string */
  metadata?: string;
  /** Similarity score (higher is more similar) */
  score: number;
}
/**
 * Clean up old SurrealDB/RocksDB files from the legacy database location
 * This should be called after confirming the SQLite migration is complete
 */
export declare function cleanupLegacyDatabase(): boolean;
/** Check if legacy SurrealDB files exist */
export declare function hasLegacyDatabase(): boolean;
/** Git repository information */
export interface GitInfo {
  /** Current branch name (None if detached HEAD) */
  branch?: string;
  /** Remote origin URL */
  remote?: string;
  /** Repository name extracted from remote */
  repoName?: string;
}
/** Git worktree information */
export interface GitWorktree {
  /** Absolute path to the worktree */
  path: string;
  /** Name of the worktree (basename of path for main, or worktree name) */
  name: string;
  /** Current branch or commit */
  head?: string;
  /** Whether this is the main worktree */
  isMain: boolean;
  /** Whether the worktree is locked */
  isLocked: boolean;
}
/**
 * Get current git branch for a directory
 * Returns None if not in a git repository or on a detached HEAD
 */
export declare function getGitBranch(directory: string): string | null;
/** Get git repository root (equivalent to `git rev-parse --show-toplevel`) */
export declare function getGitRoot(directory: string): string | null;
/**
 * Get git common directory (equivalent to `git rev-parse --git-common-dir`)
 * For worktrees, this returns the main .git directory
 */
export declare function getGitCommonDir(directory: string): string | null;
/** Get remote origin URL */
export declare function getGitRemoteUrl(directory: string): string | null;
/** Get comprehensive git info for a directory */
export declare function getGitInfo(directory: string): GitInfo;
/** List tracked files in the repository (equivalent to `git ls-files`) */
export declare function gitLsFiles(directory: string): Array<string>;
/** List git worktrees (equivalent to `git worktree list --porcelain`) */
export declare function gitWorktreeList(directory: string): Array<GitWorktree>;
/** Get git log entries (equivalent to `git log`) */
export interface GitLogEntry {
  /** Commit hash (full SHA) */
  hash: string;
  /** Short commit hash (first 8 chars) */
  shortHash: string;
  /** Commit message (first line) */
  message: string;
  /** Author name */
  authorName: string;
  /** Author email */
  authorEmail: string;
  /** Commit timestamp (ISO 8601) */
  timestamp: string;
}
/** Get git log for a directory */
export declare function gitLog(
  directory: string,
  maxCount?: number | undefined | null
): Array<GitLogEntry>;
/** Get file content at a specific commit (equivalent to `git show <commit>:<path>`) */
export declare function gitShowFile(
  directory: string,
  commit: string,
  filePath: string
): string;
/** Create a new branch from current HEAD */
export declare function gitCreateBranch(
  directory: string,
  branchName: string
): void;
/** Add a worktree at specified path for a branch */
export declare function gitWorktreeAdd(
  directory: string,
  worktreePath: string,
  branch: string
): void;
/** Remove a worktree */
export declare function gitWorktreeRemove(
  directory: string,
  worktreePath: string,
  force?: boolean | undefined | null
): void;
/** Diff statistics for a file */
export interface GitDiffStat {
  /** File path */
  path: string;
  /** Lines added */
  additions: number;
  /** Lines deleted */
  deletions: number;
  /** Change type: "added", "deleted", "modified", "renamed" */
  changeType: string;
  /** Old path (for renames) */
  oldPath?: string;
}
/**
 * Get diff between two commits - simplified version using tree comparison
 * Returns list of changed files without line counts (for now)
 */
export declare function gitDiffStat(
  directory: string,
  fromCommit: string,
  toCommit: string
): Array<GitDiffStat>;
/** Result of indexing a single JSONL file */
export interface IndexResult {
  /** Session ID that was indexed */
  sessionId: string;
  /** Number of new messages indexed */
  messagesIndexed: number;
  /** Total messages in session after indexing */
  totalMessages: number;
  /** Whether this is a new session */
  isNewSession: boolean;
  /** Any error message */
  error?: string;
}
/** Statistics about a JSONL file */
export interface JsonlStats {
  /** Number of lines in the file */
  lineCount: number;
  /** File size in bytes */
  fileSize: number;
  /** Whether an index file exists for fast access */
  hasIndex: boolean;
  /** Whether the index is stale (file modified after index) */
  indexStale: boolean;
}
/** A single line from a JSONL file */
export interface JsonlLine {
  /** Line number (0-indexed) */
  lineNumber: number;
  /** Byte offset in the file */
  byteOffset: number;
  /** Raw content of the line */
  content: string;
}
/** Result of a paginated read operation */
export interface PaginatedResult {
  /** Lines returned */
  lines: Array<JsonlLine>;
  /** Total number of lines in the file */
  totalLines: number;
  /** Whether there are more lines after this page */
  hasMore: boolean;
  /** Offset for the next page */
  nextOffset: number;
}
/** Index for fast random access to JSONL lines */
export interface JsonlIndex {
  /** Original file path */
  filePath: string;
  /** Byte offsets of each line start */
  lineOffsets: Array<number>;
  /** File modification time when index was built (Unix timestamp) */
  fileMtime: number;
  /** File size when index was built */
  fileSize: number;
}
/** Filter specification for querying JSONL */
export interface JsonlFilter {
  /** JSON path to the field (e.g., "type" or "metadata.timestamp") */
  fieldPath: string;
  /** Comparison operator: "eq", "ne", "gt", "lt", "gte", "lte", "contains" */
  operator: string;
  /** Value to compare against (as string, will be parsed based on field type) */
  value: string;
}
/** Result of a filter operation */
export interface FilterResult {
  /** Matching lines */
  lines: Array<JsonlLine>;
  /** Number of lines that matched */
  matchedCount: number;
  /** Number of lines scanned */
  scannedCount: number;
}
/** Count the number of lines in a JSONL file (fast, uses mmap + SIMD) */
export declare function jsonlCountLines(filePath: string): number;
/** Get statistics about a JSONL file */
export declare function jsonlStats(filePath: string): JsonlStats;
/** Read a page of lines from a JSONL file */
export declare function jsonlReadPage(
  filePath: string,
  offset: number,
  limit: number
): PaginatedResult;
/** Read lines in reverse order (for recent-first access) */
export declare function jsonlReadReverse(
  filePath: string,
  limit: number
): Array<JsonlLine>;
/** Build a byte offset index for fast random access */
export declare function jsonlBuildIndex(filePath: string): JsonlIndex;
/** Save an index to disk for later use */
export declare function jsonlSaveIndex(index: JsonlIndex): void;
/** Load an index from disk */
export declare function jsonlLoadIndex(filePath: string): JsonlIndex | null;
/** Read specific lines by number using an index (O(1) per line) */
export declare function jsonlReadIndexed(
  filePath: string,
  index: JsonlIndex,
  lineNumbers: Array<number>
): Array<JsonlLine>;
/** Stream lines with a callback (memory efficient for large files) */
export declare function jsonlStream(
  filePath: string,
  callback: (err: Error | null, arg: Array<JsonlLine>) => any,
  batchSize: number
): Promise<number>;
/** Filter JSONL lines by field value */
export declare function jsonlFilter(
  filePath: string,
  filters: Array<JsonlFilter>,
  limit?: number | undefined | null
): FilterResult;
/** Filter with time range (common use case, optimized) */
export declare function jsonlFilterTimeRange(
  filePath: string,
  timestampField: string,
  startTime: string,
  endTime: string,
  limit?: number | undefined | null
): FilterResult;
export interface Repo {
  id?: string;
  remote: string;
  name: string;
  defaultBranch?: string;
  createdAt?: string;
  updatedAt?: string;
}
export interface RepoInput {
  remote: string;
  name: string;
  defaultBranch?: string;
}
export interface Project {
  id?: string;
  repoId?: string;
  slug: string;
  path: string;
  relativePath?: string;
  name: string;
  isWorktree: boolean;
  sourceConfigDir?: string;
  createdAt?: string;
  updatedAt?: string;
}
export interface ProjectInput {
  repoId?: string;
  slug: string;
  path: string;
  relativePath?: string;
  name: string;
  isWorktree?: boolean;
  sourceConfigDir?: string;
}
export interface Session {
  id: string;
  projectId?: string;
  status: string;
  transcriptPath?: string;
  slug?: string;
  sourceConfigDir?: string;
  lastIndexedLine?: number;
}
export interface SessionInput {
  id: string;
  projectId?: string;
  status?: string;
  transcriptPath?: string;
  slug?: string;
  sourceConfigDir?: string;
}
export interface SessionFile {
  id: string;
  sessionId: string;
  fileType: string;
  filePath: string;
  agentId?: string;
  lastIndexedLine?: number;
  lastIndexedAt?: string;
  createdAt?: string;
}
export interface SessionSummary {
  id: string;
  sessionId: string;
  messageId: string;
  content?: string;
  rawJson?: string;
  timestamp: string;
  lineNumber: number;
  indexedAt?: string;
}
export interface SessionSummaryInput {
  sessionId: string;
  messageId: string;
  content?: string;
  rawJson?: string;
  timestamp: string;
  lineNumber: number;
}
export interface SessionCompact {
  id: string;
  sessionId: string;
  messageId: string;
  content?: string;
  rawJson?: string;
  timestamp: string;
  lineNumber: number;
  compactType?: string;
  indexedAt?: string;
}
export interface SessionCompactInput {
  sessionId: string;
  messageId: string;
  content?: string;
  rawJson?: string;
  timestamp: string;
  lineNumber: number;
  compactType?: string;
}
/** Individual todo item structure */
export interface TodoItem {
  content: string;
  status: string;
  activeForm: string;
}
export interface SessionTodos {
  id: string;
  sessionId: string;
  messageId: string;
  todosJson: string;
  timestamp: string;
  lineNumber: number;
  indexedAt?: string;
}
export interface SessionTodosInput {
  sessionId: string;
  messageId: string;
  todosJson: string;
  timestamp: string;
  lineNumber: number;
}
/** A native task from Claude Code's TaskCreate/TaskUpdate tools */
export interface NativeTask {
  id: string;
  sessionId: string;
  messageId: string;
  subject: string;
  description?: string;
  status: string;
  activeForm?: string;
  owner?: string;
  blocks?: string;
  blockedBy?: string;
  createdAt: string;
  updatedAt: string;
  completedAt?: string;
  lineNumber: number;
}
/** Input for creating a native task (from TaskCreate tool call) */
export interface NativeTaskInput {
  id: string;
  sessionId: string;
  messageId: string;
  subject: string;
  description?: string;
  activeForm?: string;
  timestamp: string;
  lineNumber: number;
}
/** Input for updating a native task (from TaskUpdate tool call) */
export interface NativeTaskUpdate {
  id: string;
  sessionId: string;
  messageId: string;
  status?: string;
  subject?: string;
  description?: string;
  activeForm?: string;
  owner?: string;
  addBlocks?: Array<string>;
  addBlockedBy?: Array<string>;
  timestamp: string;
  lineNumber: number;
}
export interface Message {
  id: string;
  sessionId: string;
  agentId?: string;
  parentId?: string;
  messageType: string;
  role?: string;
  content?: string;
  toolName?: string;
  toolInput?: string;
  toolResult?: string;
  rawJson?: string;
  timestamp: string;
  lineNumber: number;
  sourceFileName?: string;
  sourceFileType?: string;
  sentimentScore?: number;
  sentimentLevel?: string;
  frustrationScore?: number;
  frustrationLevel?: string;
  indexedAt?: string;
}
export interface MessageInput {
  id: string;
  sessionId: string;
  agentId?: string;
  parentId?: string;
  messageType: string;
  role?: string;
  content?: string;
  toolName?: string;
  toolInput?: string;
  toolResult?: string;
  rawJson?: string;
  timestamp: string;
  lineNumber: number;
  sourceFileName?: string;
  sourceFileType?: string;
  sentimentScore?: number;
  sentimentLevel?: string;
  frustrationScore?: number;
  frustrationLevel?: string;
}
export interface MessageBatch {
  sessionId: string;
  messages: Array<MessageInput>;
}
export interface Task {
  id?: string;
  sessionId?: string;
  taskId: string;
  description: string;
  taskType: string;
  outcome?: string;
  confidence?: number;
  notes?: string;
  filesModified?: Array<string>;
  testsAdded?: number;
  startedAt?: string;
  completedAt?: string;
}
export interface TaskInput {
  sessionId?: string;
  taskId: string;
  description: string;
  taskType: string;
  estimatedComplexity?: string;
}
export interface TaskCompletion {
  taskId: string;
  outcome: string;
  confidence: number;
  notes?: string;
  filesModified?: Array<string>;
  testsAdded?: number;
}
export interface TaskFailure {
  taskId: string;
  reason: string;
  attemptedSolutions?: Array<string>;
  confidence?: number;
  notes?: string;
}
export interface TaskMetrics {
  totalTasks: number;
  completedTasks: number;
  successfulTasks: number;
  partialTasks: number;
  failedTasks: number;
  successRate: number;
  averageConfidence?: number;
  averageDurationSeconds?: number;
  calibrationScore?: number;
  byType?: string;
  byOutcome?: string;
}
export interface Orchestration {
  id: string;
  sessionId?: string;
  hookType: string;
  projectRoot: string;
  status: string;
  totalHooks: number;
  completedHooks: number;
  failedHooks: number;
  deferredHooks: number;
  createdAt?: string;
  completedAt?: string;
}
export interface OrchestrationInput {
  sessionId?: string;
  hookType: string;
  projectRoot: string;
}
export interface OrchestrationUpdate {
  id: string;
  status?: string;
  totalHooks?: number;
  completedHooks?: number;
  failedHooks?: number;
  deferredHooks?: number;
}
export interface HookExecution {
  id?: string;
  orchestrationId?: string;
  sessionId?: string;
  taskId?: string;
  hookType: string;
  hookName: string;
  hookSource?: string;
  directory?: string;
  durationMs: number;
  exitCode: number;
  passed: boolean;
  output?: string;
  error?: string;
  ifChanged?: string;
  command?: string;
  executedAt?: string;
  status?: string;
  consecutiveFailures?: number;
  maxAttempts?: number;
  pid?: number;
  pluginRoot?: string;
}
export interface HookExecutionInput {
  sessionId?: string;
  taskId?: string;
  hookType: string;
  hookName: string;
  hookSource?: string;
  directory?: string;
  durationMs: number;
  exitCode: number;
  passed: boolean;
  output?: string;
  error?: string;
  ifChanged?: string;
  command?: string;
}
/** Information about hook attempt status for deferred execution */
export interface HookAttemptInfo {
  consecutiveFailures: number;
  maxAttempts: number;
  isStuck: boolean;
}
/** Input for queuing a pending hook */
export interface PendingHookInput {
  orchestrationId: string;
  sessionId?: string;
  hookType: string;
  hookName: string;
  plugin: string;
  directory: string;
  command: string;
  ifChanged?: string;
  pid?: number;
  pluginRoot?: string;
}
/** Input for queueing a hook in pending_hooks table (for --check mode) */
export interface QueuedHookInput {
  orchestrationId: string;
  plugin: string;
  hookName: string;
  directory: string;
  ifChanged?: string;
  command: string;
}
/** Queued hook record from pending_hooks table */
export interface QueuedHook {
  id: string;
  orchestrationId: string;
  plugin: string;
  hookName: string;
  directory: string;
  ifChanged?: string;
  command: string;
  queuedAt: string;
}
export interface HookStats {
  totalExecutions: number;
  totalPassed: number;
  totalFailed: number;
  passRate: number;
  uniqueHooks: number;
  byHookType?: string;
}
export interface FrustrationEvent {
  id?: string;
  sessionId?: string;
  taskId?: string;
  frustrationLevel: string;
  frustrationScore: number;
  userMessage: string;
  detectedSignals?: string;
  context?: string;
  recordedAt?: string;
}
export interface FrustrationEventInput {
  sessionId?: string;
  taskId?: string;
  frustrationLevel: string;
  frustrationScore: number;
  userMessage: string;
  detectedSignals?: Array<string>;
  context?: string;
}
export interface FrustrationMetrics {
  totalFrustrations: number;
  significantFrustrations: number;
  frustrationRate: number;
  significantFrustrationRate: number;
  weightedScore: number;
  byLevel?: string;
}
export interface SessionFileChange {
  id?: string;
  sessionId: string;
  filePath: string;
  action: string;
  fileHashBefore?: string;
  fileHashAfter?: string;
  toolName?: string;
  recordedAt?: string;
}
export interface SessionFileChangeInput {
  sessionId: string;
  filePath: string;
  action: string;
  fileHashBefore?: string;
  fileHashAfter?: string;
  toolName?: string;
}
export interface SessionFileValidation {
  id?: string;
  sessionId: string;
  filePath: string;
  fileHash: string;
  pluginName: string;
  hookName: string;
  directory: string;
  commandHash: string;
  validatedAt?: string;
}
export interface SessionFileValidationInput {
  sessionId: string;
  filePath: string;
  fileHash: string;
  pluginName: string;
  hookName: string;
  directory: string;
  commandHash: string;
}
/**
 * Represents a file that this session modified, along with its validation status.
 * Used for determining which files need validation with stale detection.
 */
export interface FileValidationStatus {
  /** The file path */
  filePath: string;
  /** Hash after this session's modification (from session_file_changes) */
  modificationHash: string;
  /** Hash after last validation by this hook (from session_file_validations), if any */
  validationHash?: string;
  /** Command hash used in last validation, if any */
  validationCommandHash?: string;
}
/**
 * A generated session summary (created by Han using Haiku for semantic analysis)
 * Unlike SessionSummary (Claude's native context compression), these contain
 * extracted topics, files, tools, and outcome assessment.
 */
export interface GeneratedSessionSummary {
  id: string;
  sessionId: string;
  summaryText: string;
  topics: Array<string>;
  filesModified?: Array<string>;
  toolsUsed?: Array<string>;
  outcome?: string;
  messageCount?: number;
  durationSeconds?: number;
  createdAt?: string;
  updatedAt?: string;
}
/** Input for creating/updating a generated session summary */
export interface GeneratedSessionSummaryInput {
  sessionId: string;
  summaryText: string;
  topics: Array<string>;
  filesModified?: Array<string>;
  toolsUsed?: Array<string>;
  outcome?: string;
  messageCount?: number;
  durationSeconds?: number;
}
/**
 * A registered config directory for multi-environment support
 * The central coordinator tracks all CLAUDE_CONFIG_DIR locations to index
 */
export interface ConfigDir {
  id: string;
  path: string;
  name?: string;
  registeredAt: string;
  lastIndexedAt?: string;
  sessionCount?: number;
  isDefault: boolean;
}
/** Input for registering a new config directory */
export interface ConfigDirInput {
  path: string;
  name?: string;
  isDefault?: boolean;
}
/** A file operation extracted from transcript content */
export interface FileOperation {
  /** File path */
  path: string;
  /** Operation type: "read", "write", "edit", "delete" */
  operation: string;
}
/** Result of file operation extraction */
export interface ExtractionResult {
  /** Extracted file operations */
  operations: Array<FileOperation>;
  /** Number of patterns matched */
  patternMatches: number;
}
/** Session file info */
export interface SessionFile {
  /** File name (without directory) */
  name: string;
  /** Full path */
  path: string;
  /** File size in bytes */
  size: number;
  /** Last modified timestamp (Unix ms) */
  modified: number;
}
/**
 * Extract file operations from transcript message content
 *
 * This is a high-performance replacement for the TypeScript regex extraction.
 * Uses compiled regex patterns for speed.
 */
export declare function extractFileOperations(
  content: string
): ExtractionResult;
/** Extract file operations from multiple messages (batch processing) */
export declare function extractFileOperationsBatch(
  contents: Array<string>
): Array<ExtractionResult>;
/**
 * List JSONL session files in a directory
 *
 * Returns files sorted by modification time (newest first).
 */
export declare function listSessionFiles(dirPath: string): Array<SessionFile>;
/**
 * List JSONL files matching a pattern in a directory
 *
 * More flexible than list_session_files - allows custom prefix/suffix matching.
 */
export declare function listJsonlFiles(
  dirPath: string,
  prefix?: string | undefined | null,
  suffix?: string | undefined | null
): Array<SessionFile>;
/**
 * Get all pending index results and clear the queue
 * TypeScript calls this periodically to get results and publish subscription events
 */
export declare function pollIndexResults(): Array<IndexResult>;
/** Event type for file changes */
export enum FileEventType {
  Created = 'Created',
  Modified = 'Modified',
  Removed = 'Removed',
}
/** File change event */
export interface FileEvent {
  /** Type of file event */
  eventType: FileEventType;
  /** Absolute path to the file */
  path: string;
  /** Session ID extracted from the filename (if applicable) */
  sessionId?: string;
  /** Project path extracted from the directory structure */
  projectPath?: string;
}
/**
 * Start watching the Claude projects directory for JSONL changes
 * Returns true if watcher was started, false if already running
 */
export declare function startFileWatcher(
  watchPath?: string | undefined | null
): boolean;
/**
 * Add an additional watch path for multi-environment support
 * Returns true if the path was added, false if already watching or watcher not running
 */
export declare function addWatchPath(
  configDir: string,
  projectsPath?: string | undefined | null
): boolean;
/**
 * Remove a watch path
 * Returns true if the path was removed, false if not watching or watcher not running
 */
export declare function removeWatchPath(configDir: string): boolean;
/** Get all currently watched paths */
export declare function getWatchedPaths(): Array<string>;
/** Stop the file watcher */
export declare function stopFileWatcher(): boolean;
/**
 * Register a callback to be called when new index results are ready
 * This enables event-driven updates instead of polling
 * The callback receives IndexResult objects directly
 */
export declare function setIndexCallback(
  callback: (result: IndexResult) => void
): void;
/** Clear the index callback (revert to polling mode) */
export declare function clearIndexCallback(): void;
/** Check if the file watcher is running */
export declare function isWatcherRunning(): boolean;
/** Get the default watch path (~/.claude/projects) */
export declare function getDefaultWatchPath(): string;
/**
 * Compute SHA256 hash of a file's contents
 * Returns empty string if file cannot be read
 */
export declare function computeFileHash(filePath: string): string;
/**
 * Compute SHA256 hashes for multiple files in parallel
 * Returns a map of file path to hash
 */
export declare function computeFileHashesParallel(
  filePaths: Array<string>
): Record<string, string>;
/**
 * Find files matching glob patterns in a directory, respecting gitignore
 * Returns absolute file paths
 */
export declare function findFilesWithGlob(
  rootDir: string,
  patterns: Array<string>
): Array<string>;
/**
 * Find directories containing marker files or directories
 * Returns absolute directory paths
 */
export declare function findDirectoriesWithMarkers(
  rootDir: string,
  markers: Array<string>
): Array<string>;
/** Build a manifest of file hashes for given files */
export declare function buildManifest(
  files: Array<string>,
  rootDir: string
): Record<string, string>;
/** Check if any files have changed compared to a cached manifest */
export declare function hasChanges(
  rootDir: string,
  patterns: Array<string>,
  cachedManifest: Record<string, string>
): boolean;
export interface CheckResult {
  hasChanges: boolean;
  manifest: Record<string, string>;
  files: Array<string>;
}
/** Efficiently check for changes and build manifest in one pass */
export declare function checkAndBuildManifest(
  rootDir: string,
  patterns: Array<string>,
  cachedManifest?: Record<string, string> | undefined | null
): CheckResult;
/**
 * Initialize or open a database at the given path
 * Note: db_path is kept for API compatibility but the singleton uses ~/.han/han.db
 */
export declare function dbInit(dbPath: string): boolean;
/**
 * Check if database needs reindex (after schema upgrade or version change)
 * Call this on coordinator startup and trigger fullScanAndIndex if true
 */
export declare function needsReindex(): boolean;
/** Clear the needs_reindex flag after successful reindex */
export declare function clearReindexFlag(): void;
/** Index documents for FTS */
export declare function ftsIndex(
  dbPath: string,
  tableName: string,
  documents: Array<FtsDocument>
): number;
/** Search documents using FTS (BM25) */
export declare function ftsSearch(
  dbPath: string,
  tableName: string,
  query: string,
  limit?: number | undefined | null
): Array<FtsSearchResult>;
/** Delete documents by ID */
export declare function ftsDelete(
  dbPath: string,
  tableName: string,
  ids: Array<string>
): number;
/** Input for vector document indexing (napi-compatible) */
export interface VectorDocumentInput {
  id: string;
  content: string;
  vector: Array<number>;
  metadata?: string;
}
/** Index documents with vectors */
export declare function vectorIndex(
  dbPath: string,
  tableName: string,
  documents: Array<VectorDocumentInput>
): number;
/** Search documents using vector similarity */
export declare function vectorSearch(
  dbPath: string,
  tableName: string,
  queryVector: Array<number>,
  limit?: number | undefined | null
): Array<VectorSearchResult>;
/** Check if ONNX Runtime is available (downloaded) */
export declare function embeddingIsAvailable(): Promise<boolean>;
/**
 * Ensure ONNX Runtime and model are downloaded
 * Returns path to the ONNX Runtime library
 */
export declare function embeddingEnsureAvailable(): Promise<string>;
/** Generate embeddings for a list of texts */
export declare function generateEmbeddings(
  texts: Array<string>
): Promise<Array<Array<number>>>;
/** Generate embedding for a single text */
export declare function generateEmbedding(text: string): Promise<Array<number>>;
/** Get the embedding dimension (384 for all-MiniLM-L6-v2) */
export declare function getEmbeddingDimension(): number;
/** Create or update a repo record */
export declare function upsertRepo(dbPath: string, input: RepoInput): Repo;
/** Get a repo by its remote URL */
export declare function getRepoByRemote(
  dbPath: string,
  remote: string
): Repo | null;
/** List all repos */
export declare function listRepos(dbPath: string): Array<Repo>;
/** Create or update a project record */
export declare function upsertProject(
  dbPath: string,
  input: ProjectInput
): Project;
/** Get a project by its slug */
export declare function getProjectBySlug(
  dbPath: string,
  slug: string
): Project | null;
/** Get a project by its absolute path */
export declare function getProjectByPath(
  dbPath: string,
  path: string
): Project | null;
/** List projects, optionally filtered by repo */
export declare function listProjects(
  dbPath: string,
  repoId?: string | undefined | null
): Array<Project>;
/** Create or update a session record */
export declare function upsertSession(
  dbPath: string,
  input: SessionInput
): Session;
/** Mark a session as completed */
export declare function endSession(dbPath: string, sessionId: string): boolean;
/** Get a session by ID */
export declare function getSession(
  dbPath: string,
  sessionId: string
): Session | null;
/** List sessions with optional filters */
export declare function listSessions(
  dbPath: string,
  projectId?: string | undefined | null,
  status?: string | undefined | null,
  limit?: number | undefined | null
): Array<Session>;
/**
 * Reset all sessions for re-indexing
 * Sets last_indexed_line to 0 so all messages will be re-processed
 * Use this when you need to backfill raw_json or other fields
 */
export declare function resetAllSessionsForReindex(dbPath: string): number;
/** Register a config directory for multi-environment indexing */
export declare function registerConfigDir(
  dbPath: string,
  input: ConfigDirInput
): ConfigDir;
/** Get a config directory by path */
export declare function getConfigDirByPath(
  dbPath: string,
  path: string
): ConfigDir | null;
/** List all registered config directories */
export declare function listConfigDirs(dbPath: string): Array<ConfigDir>;
/** Update the last indexed timestamp for a config directory */
export declare function updateConfigDirLastIndexed(
  dbPath: string,
  path: string
): boolean;
/** Remove a config directory from the registry */
export declare function unregisterConfigDir(
  dbPath: string,
  path: string
): boolean;
/** Get the default config directory */
export declare function getDefaultConfigDir(dbPath: string): ConfigDir | null;
/** Insert a batch of messages for a session */
export declare function insertMessagesBatch(
  dbPath: string,
  sessionId: string,
  messages: Array<MessageInput>
): number;
/** Get a message by ID */
export declare function getMessage(
  dbPath: string,
  messageId: string
): Message | null;
/**
 * List messages for a session with optional type filter, agent filter, and pagination
 * agent_id_filter behavior:
 *   - undefined/null: returns all messages (main + agent)
 *   - empty string "": returns only main conversation (agent_id IS NULL)
 *   - non-empty string: returns only messages from that specific agent
 */
export declare function listSessionMessages(
  dbPath: string,
  sessionId: string,
  messageType?: string | undefined | null,
  agentIdFilter?: string | undefined | null,
  limit?: number | undefined | null,
  offset?: number | undefined | null
): Array<Message>;
/** Get message count for a session */
export declare function getMessageCount(
  dbPath: string,
  sessionId: string
): number;
/**
 * Get message counts for multiple sessions in a single query
 * Returns a map of session_id -> count
 */
export declare function getMessageCountsBatch(
  dbPath: string,
  sessionIds: Array<string>
): Record<string, number>;
/** Get the last indexed line number for incremental indexing */
export declare function getLastIndexedLine(
  dbPath: string,
  sessionId: string
): number;
/** Session timestamps returned by get_session_timestamps_batch */
export interface SessionTimestamps {
  sessionId: string;
  startedAt?: string;
  endedAt?: string;
}
/**
 * Get first/last message timestamps for multiple sessions in a single query
 * Returns a map of session_id -> SessionTimestamps
 */
export declare function getSessionTimestampsBatch(
  dbPath: string,
  sessionIds: Array<string>
): Record<string, SessionTimestamps>;
/** Search messages using FTS */
export declare function searchMessages(
  dbPath: string,
  query: string,
  sessionId?: string | undefined | null,
  limit?: number | undefined | null
): Array<Message>;
/** Create a new task record */
export declare function createTask(dbPath: string, input: TaskInput): Task;
/** Mark a task as completed with outcome */
export declare function completeTask(
  dbPath: string,
  completion: TaskCompletion
): Task;
/** Mark a task as failed */
export declare function failTask(dbPath: string, failure: TaskFailure): Task;
/** Get a task by ID */
export declare function getTask(dbPath: string, taskId: string): Task | null;
/** Query task metrics with optional filters */
export declare function queryTaskMetrics(
  dbPath: string,
  taskType?: string | undefined | null,
  outcome?: string | undefined | null,
  period?: string | undefined | null
): TaskMetrics;
/** Record a hook execution */
export declare function recordHookExecution(
  dbPath: string,
  input: HookExecutionInput
): HookExecution;
/** Query hook statistics */
export declare function queryHookStats(
  dbPath: string,
  period?: string | undefined | null
): HookStats;
/** Create a new orchestration, cancelling any existing running orchestration for the same session */
export declare function createOrchestration(
  input: OrchestrationInput
): Orchestration;
/** Get an orchestration by ID */
export declare function getOrchestration(id: string): Orchestration | null;
/** Update an orchestration's counters and status */
export declare function updateOrchestration(update: OrchestrationUpdate): void;
/** Cancel an orchestration and all its pending/running hooks */
export declare function cancelOrchestration(id: string): void;
/** Get all hooks for an orchestration */
export declare function getOrchestrationHooks(
  orchestrationId: string
): Array<HookExecution>;
/** Queue a hook for later execution during --wait */
export declare function queueHook(input: QueuedHookInput): string;
/** Get all queued hooks for an orchestration */
export declare function getQueuedHooks(
  orchestrationId: string
): Array<QueuedHook>;
/** Delete queued hooks after they've been executed */
export declare function deleteQueuedHooks(orchestrationId: string): number;
/** Queue a pending hook for background execution */
export declare function queuePendingHook(input: PendingHookInput): string;
/** Get all pending hooks ready to run */
export declare function getPendingHooks(): Array<HookExecution>;
/** Get pending/running/failed hooks for a specific session */
export declare function getSessionPendingHooks(
  sessionId: string
): Array<HookExecution>;
/** Update hook execution status */
export declare function updateHookStatus(id: string, status: string): void;
/** Complete a hook execution */
export declare function completeHookExecution(
  id: string,
  success: boolean,
  output: string | undefined | null,
  error: string | undefined | null,
  durationMs: number
): void;
/** Mark a hook as failed with an error message */
export declare function failHookExecution(
  id: string,
  errorMessage: string
): void;
/** Get or create hook attempt info for tracking consecutive failures */
export declare function getOrCreateHookAttempt(
  sessionId: string,
  plugin: string,
  hookName: string,
  directory: string
): HookAttemptInfo;
/** Increment consecutive_failures for a hook */
export declare function incrementHookFailures(
  sessionId: string,
  plugin: string,
  hookName: string,
  directory: string
): HookAttemptInfo;
/** Reset consecutive_failures to 0 (on success) */
export declare function resetHookFailures(
  sessionId: string,
  plugin: string,
  hookName: string,
  directory: string
): void;
/** Increase max_attempts for a hook (user override via MCP tool) */
export declare function increaseHookMaxAttempts(
  sessionId: string,
  plugin: string,
  hookName: string,
  directory: string,
  increase: number
): void;
/** Record a frustration event */
export declare function recordFrustration(
  dbPath: string,
  input: FrustrationEventInput
): FrustrationEvent;
/** Query frustration metrics */
export declare function queryFrustrationMetrics(
  dbPath: string,
  period: string | undefined | null,
  totalTasks: number
): FrustrationMetrics;
/** Record a file change in a session */
export declare function recordFileChange(
  dbPath: string,
  input: SessionFileChangeInput
): SessionFileChange;
/** Get file changes for a session */
export declare function getSessionFileChanges(
  dbPath: string,
  sessionId: string
): Array<SessionFileChange>;
/** Check if a session has any file changes */
export declare function hasSessionChanges(
  dbPath: string,
  sessionId: string
): boolean;
/** Record a file validation (upserts based on session/file/plugin/hook) */
export declare function recordFileValidation(
  dbPath: string,
  input: SessionFileValidationInput
): SessionFileValidation;
/** Get a specific file validation */
export declare function getFileValidation(
  dbPath: string,
  sessionId: string,
  filePath: string,
  pluginName: string,
  hookName: string,
  directory: string
): SessionFileValidation | null;
/** Get all validations for a session and plugin/hook/directory combo */
export declare function getSessionValidations(
  dbPath: string,
  sessionId: string,
  pluginName: string,
  hookName: string,
  directory: string
): Array<SessionFileValidation>;
/** Check if files need validation (any changed since last validation or command changed) */
export declare function needsValidation(
  dbPath: string,
  sessionId: string,
  pluginName: string,
  hookName: string,
  directory: string,
  commandHash: string
): boolean;
/**
 * Get ALL file validations for a session (not filtered by plugin/hook)
 * Useful for showing validation status across all hooks for file changes
 */
export declare function getAllSessionValidations(
  dbPath: string,
  sessionId: string
): Array<SessionFileValidation>;
/**
 * Get files this session modified along with their validation status.
 * Used for stale detection: compare current disk hash against modification_hash
 * and validation_hash to determine if validation is needed.
 */
export declare function getFilesForValidation(
  dbPath: string,
  sessionId: string,
  pluginName: string,
  hookName: string,
  directory: string
): Array<FileValidationStatus>;
/**
 * Delete stale validation records for files that no longer exist.
 * This prevents "ghost" validations from causing infinite re-validation loops.
 */
export declare function deleteStaleValidations(
  dbPath: string,
  sessionId: string,
  pluginName: string,
  hookName: string,
  directory: string,
  currentFilePaths: Array<string>
): number;
/** Upsert a session summary (keeps the latest by timestamp) */
export declare function upsertSessionSummary(
  dbPath: string,
  input: SessionSummaryInput
): SessionSummary;
/** Get session summary by session ID */
export declare function getSessionSummary(
  dbPath: string,
  sessionId: string
): SessionSummary | null;
/** Upsert a session compact (keeps the latest by timestamp) */
export declare function upsertSessionCompact(
  dbPath: string,
  input: SessionCompactInput
): SessionCompact;
/** Get session compact by session ID */
export declare function getSessionCompact(
  dbPath: string,
  sessionId: string
): SessionCompact | null;
/** Upsert session todos (keeps the latest by timestamp) */
export declare function upsertSessionTodos(
  dbPath: string,
  input: SessionTodosInput
): SessionTodos;
/** Get session todos by session ID */
export declare function getSessionTodos(
  dbPath: string,
  sessionId: string
): SessionTodos | null;
/** Upsert a generated session summary (creates or updates based on session_id) */
export declare function upsertGeneratedSummary(
  dbPath: string,
  input: GeneratedSessionSummaryInput
): GeneratedSessionSummary;
/** Get generated summary by session ID */
export declare function getGeneratedSummary(
  dbPath: string,
  sessionId: string
): GeneratedSessionSummary | null;
/** Search generated summaries using FTS */
export declare function searchGeneratedSummaries(
  dbPath: string,
  query: string,
  limit?: number | undefined | null
): Array<GeneratedSessionSummary>;
/**
 * List sessions that don't have generated summaries yet
 * Returns session IDs ordered by most recent first
 */
export declare function listSessionsWithoutSummaries(
  dbPath: string,
  limit?: number | undefined | null
): Array<string>;
/** Get all native tasks for a session */
export declare function getSessionNativeTasks(
  dbPath: string,
  sessionId: string
): Array<NativeTask>;
/** Get a specific native task by session ID and task ID */
export declare function getNativeTask(
  dbPath: string,
  sessionId: string,
  taskId: string
): NativeTask | null;
/** Try to acquire the coordinator lock (single-instance indexer pattern) */
export declare function tryAcquireCoordinatorLock(): boolean;
/** Release the coordinator lock */
export declare function releaseCoordinatorLock(): boolean;
/** Update coordinator heartbeat (call periodically while coordinating) */
export declare function updateCoordinatorHeartbeat(): boolean;
/** Get current coordinator status */
export declare function getCoordinatorStatus(): CoordinatorStatus;
/** Check if this process is the coordinator */
export declare function isCoordinator(): boolean;
/** Get the heartbeat interval in seconds */
export declare function getHeartbeatInterval(): number;
/** Get the stale lock timeout in seconds */
export declare function getStaleLockTimeout(): number;
/**
 * Clean up a stale coordinator lock file
 * Returns true if a stale lock was cleaned up, false otherwise
 */
export declare function cleanupStaleCoordinatorLock(): boolean;
/**
 * Index a single JSONL session file incrementally
 * Only processes lines after the last indexed line
 * Task association for sentiment events is loaded from SQLite automatically
 */
export declare function indexSessionFile(
  dbPath: string,
  filePath: string,
  sourceConfigDir?: string | undefined | null
): IndexResult;
/** Index all JSONL files in a project directory */
export declare function indexProjectDirectory(
  dbPath: string,
  projectDir: string,
  sourceConfigDir?: string | undefined | null
): Array<IndexResult>;
/** Handle a file event from the watcher (coordinator use only) */
export declare function handleFileEvent(
  dbPath: string,
  eventType: FileEventType,
  filePath: string,
  sessionId?: string | undefined | null,
  projectPath?: string | undefined | null
): IndexResult | null;
/**
 * Perform a full scan and index of all Claude Code sessions
 * Should be called on coordinator startup
 */
export declare function fullScanAndIndex(dbPath: string): Array<IndexResult>;
/**
 * Enqueue a hook for async execution
 * First cancels any pending hooks with the same dedup key and merges file paths
 */
export declare function enqueueAsyncHook(
  dbPath: string,
  input: AsyncHookQueueInputNative
): string;
/** List pending async hooks for a session */
export declare function listPendingAsyncHooks(
  dbPath: string,
  sessionId: string
): Array<AsyncHookQueueEntry>;
/** Check if the async hook queue is empty for a session */
export declare function isAsyncHookQueueEmpty(
  dbPath: string,
  sessionId: string
): boolean;
/** Drain the queue - get all pending hooks and mark as running */
export declare function drainAsyncHookQueue(
  dbPath: string,
  sessionId: string
): Array<AsyncHookQueueEntry>;
/** Cancel pending hooks matching dedup key and return merged file paths */
export declare function cancelPendingAsyncHooks(
  dbPath: string,
  sessionId: string,
  cwd: string,
  plugin: string,
  hookName: string
): Array<string>;
/** Complete an async hook execution */
export declare function completeAsyncHook(
  dbPath: string,
  id: string,
  success: boolean,
  result?: string | undefined | null,
  error?: string | undefined | null
): void;
/** Cancel a specific async hook by ID */
export declare function cancelAsyncHook(dbPath: string, id: string): void;
/**
 * Clear all async hooks for a session (used on SessionEnd to clean up)
 * Returns the number of hooks that were cleared
 */
export declare function clearAsyncHookQueueForSession(
  dbPath: string,
  sessionId: string
): number;
/**
 * Truncate all derived tables (those populated from JSONL logs).
 * This is used during reindex to rebuild the database from scratch.
 * Preserves: repos, projects (discovered from disk/git, not from logs)
 * Returns: Number of rows deleted across all tables
 */
export declare function truncateDerivedTables(dbPath: string): number;
