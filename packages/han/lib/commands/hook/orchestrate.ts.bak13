import { execSync, spawn } from "node:child_process";
import { createHash, randomUUID } from "node:crypto";
import {
	appendFileSync,
	existsSync,
	mkdirSync,
	readFileSync,
	realpathSync,
	writeFileSync,
} from "node:fs";
import { join } from "node:path";
import type { Command } from "commander";
import {
	getClaudeConfigDir,
	getMergedPluginsAndMarketplaces,
	getProjectDir,
	type MarketplaceConfig,
} from "../../config/claude-settings.ts";
import { getPluginHookSettings } from "../../config/han-settings.ts";
import { hookAttempts, messages } from "../../db/index.ts";
import {
	getEventLogger,
	getOrCreateEventLogger,
	initEventLogger,
} from "../../events/logger.ts";
import {
	checkForChangesAsync,
	findDirectoriesWithMarkers,
	hookMatchesEvent,
	loadPluginConfig,
	type PluginHookDefinition,
	trackFilesAsync,
} from "../../hooks/index.ts";
import { acquireGlobalSlot } from "../../hooks/slot-client.ts";
import { isDebugMode } from "../../shared.ts";
import { getCacheKeyForDirectory } from "../../validate.ts";

/**
 * Get the han binary invocation string.
 * Uses the current process's execPath and script to ensure
 * we invoke the same han binary for child processes.
 */
function getHanBinary(): string {
	// process.execPath = runtime (bun/node)
	// process.argv[1] = script path (e.g., /path/to/lib/main.ts)
	const scriptPath = process.argv[1];
	if (scriptPath) {
		return `"${process.execPath}" "${scriptPath}"`;
	}
	// Fallback to 'han' from PATH if we can't determine the script
	return "han";
}

/**
 * Replace 'han ' prefix in commands with the actual binary invocation.
 * This ensures inner han commands use the same version as the orchestrator.
 */
function resolveHanCommand(command: string): string {
	const hanBinary = getHanBinary();
	// Replace 'han ' at the start of the command
	if (command.startsWith("han ")) {
		return hanBinary + command.slice(3);
	}
	return command;
}

/**
 * Result of running a command with timeout
 */
interface CommandWithTimeoutResult {
	completed: boolean;
	success: boolean;
	output: string;
	error: string;
	exitCode: number;
	duration: number;
}

/**
 * Run a command synchronously and wait for it to complete.
 * Logs output in real-time to stderr for immediate visibility.
 *
 * @param command - The shell command to run
 * @param cwd - Working directory
 * @param env - Environment variables
 * @param payloadJson - JSON payload to pass via stdin
 * @returns Result with success/failure status
 */
async function runCommandSync(
	command: string,
	cwd: string,
	env: Record<string, string | undefined>,
	payloadJson: string,
): Promise<CommandWithTimeoutResult> {
	const startTime = Date.now();

	return new Promise((resolve) => {
		let stdout = "";
		let stderr = "";

		const proc = spawn("/bin/bash", ["-c", command], {
			cwd,
			env: { ...process.env, ...env },
		});

		// Write payload to stdin
		proc.stdin.write(payloadJson);
		proc.stdin.end();

		// Stream output to stderr in real-time for visibility
		proc.stdout.on("data", (data) => {
			const text = data.toString();
			stdout += text;
			process.stderr.write(text);
		});

		proc.stderr.on("data", (data) => {
			const text = data.toString();
			stderr += text;
			process.stderr.write(text);
		});

		proc.on("close", (code) => {
			resolve({
				completed: true,
				success: code === 0,
				output: stdout,
				error: stderr,
				exitCode: code ?? 1,
				duration: Date.now() - startTime,
			});
		});

		proc.on("error", (err) => {
			resolve({
				completed: true,
				success: false,
				output: stdout,
				error: err.message,
				exitCode: 1,
				duration: Date.now() - startTime,
			});
		});
	});
}

/**
 * Run a command with a timeout. If the command doesn't complete within the timeout,
 * returns { completed: false } so the caller can defer to background execution.
 *
 * @deprecated This function is no longer used. Wait mode now uses runCommandSync for fully synchronous execution.
 * @param command - The shell command to run
 * @param cwd - Working directory
 * @param env - Environment variables
 * @param payloadJson - JSON payload to pass via stdin
 * @param timeoutMs - Maximum time to wait before returning (default: 5000ms)
 * @returns Result with completed flag indicating if finished within timeout
 */
async function _runCommandWithTimeout(
	command: string,
	cwd: string,
	env: Record<string, string | undefined>,
	payloadJson: string,
	timeoutMs = 5000,
): Promise<CommandWithTimeoutResult> {
	const startTime = Date.now();

	return new Promise((resolve) => {
		let stdout = "";
		let stderr = "";
		let resolved = false;

		const proc = spawn("/bin/bash", ["-c", command], {
			cwd,
			env: { ...process.env, ...env },
		});

		// Write payload to stdin
		proc.stdin.write(payloadJson);
		proc.stdin.end();

		proc.stdout.on("data", (data) => {
			stdout += data.toString();
		});

		proc.stderr.on("data", (data) => {
			stderr += data.toString();
		});

		// Set up timeout
		const timer = setTimeout(() => {
			if (!resolved) {
				resolved = true;
				// Don't kill the process - it will continue running
				// The coordinator will pick it up via pendingHooks
				resolve({
					completed: false,
					success: false,
					output: stdout,
					error: "timeout - deferred to background",
					exitCode: -1,
					duration: Date.now() - startTime,
				});
			}
		}, timeoutMs);

		proc.on("close", (code) => {
			clearTimeout(timer);
			if (!resolved) {
				resolved = true;
				resolve({
					completed: true,
					success: code === 0,
					output: stdout,
					error: stderr,
					exitCode: code ?? 1,
					duration: Date.now() - startTime,
				});
			}
		});

		proc.on("error", (err) => {
			clearTimeout(timer);
			if (!resolved) {
				resolved = true;
				resolve({
					completed: true,
					success: false,
					output: stdout,
					error: err.message,
					exitCode: 1,
					duration: Date.now() - startTime,
				});
			}
		});
	});
}

/**
 * ANSI color codes for CLI output
 */
const colors = {
	reset: "\x1b[0m",
	dim: "\x1b[2m",
	cyan: "\x1b[36m",
	green: "\x1b[32m",
	red: "\x1b[31m",
	yellow: "\x1b[33m",
	bold: "\x1b[1m",
	magenta: "\x1b[35m",
};

/**
 * Format duration in human-readable form
 */
function formatDuration(ms: number): string {
	if (ms < 1000) {
		return `${ms}ms`;
	}
	const seconds = ms / 1000;
	if (seconds < 60) {
		return `${seconds.toFixed(1)}s`;
	}
	const minutes = Math.floor(seconds / 60);
	const remainingSeconds = seconds % 60;
	return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}

/**
 * Get the log file path for an orchestration
 */
function getOrchestrationLogPath(orchestrationId: string): string {
	const configDir =
		getClaudeConfigDir() || join(process.env.HOME || "", ".claude");
	const logsDir = join(configDir, "han", "logs");
	mkdirSync(logsDir, { recursive: true });
	return join(logsDir, `${orchestrationId}.log`);
}

/**
 * Initialize orchestration log file
 */
function initOrchestrationLog(
	orchestrationId: string,
	eventType: string,
	projectRoot: string,
): string {
	const logPath = getOrchestrationLogPath(orchestrationId);
	const header = `Han Hook Orchestration Log
========================
Orchestration ID: ${orchestrationId}
Event Type: ${eventType}
Project Root: ${projectRoot}
Started: ${new Date().toISOString()}

`;
	writeFileSync(logPath, header);
	return logPath;
}

/**
 * Append to orchestration log file
 */
function appendToOrchestrationLog(logPath: string, content: string): void {
	appendFileSync(logPath, content);
}

/**
 * Hook payload structure from Claude Code stdin
 * These are the common fields that Claude Code sends with hook invocations.
 */
interface HookPayload {
	// Common fields (always present from Claude Code)
	session_id?: string;
	transcript_path?: string;
	cwd?: string;
	permission_mode?: string;

	// Event-specific fields
	hook_event_name?: string;
	agent_id?: string;
	agent_type?: string;
	tool_name?: string;

	// Stop hook specific - indicates this is a retry after a previous stop hook failure
	// When true, we track consecutive failures for attempt tracking
	stop_hook_active?: boolean;
}

/**
 * Get the active session ID for the current project from the database.
 * This is used when hooks run without stdin payload (e.g., Stop hook).
 */
function getActiveSessionId(projectRoot: string): string | null {
	try {
		const { getActiveSessionForProject } = require("../../db/index.ts");
		const session = getActiveSessionForProject(projectRoot);
		if (isDebugMode()) {
			console.error(
				`${colors.dim}[orchestrate]${colors.reset} getActiveSessionId: projectRoot=${projectRoot}, session=${session?.id || "null"}`,
			);
		}
		return session?.id || null;
	} catch (error) {
		console.error(
			`${colors.dim}[orchestrate]${colors.reset} Failed to get active session: ${error}`,
		);
		return null;
	}
}

/**
 * Generate a CLI payload when running orchestrate directly from command line.
 * This mimics the payload structure that Claude Code would send.
 */
function generateCliPayload(
	eventType: string,
	projectRoot: string,
): HookPayload {
	// Use current session ID from multiple sources (in order of preference):
	// 1. HAN_SESSION_ID - explicit override from hook dispatch
	// 2. CLAUDE_SESSION_ID - may be set by Claude Code environment
	// 3. Active session from database - lookup current active session for this project
	// 4. Generate new CLI session ID - fallback for standalone CLI usage
	const sessionId =
		process.env.HAN_SESSION_ID ||
		process.env.CLAUDE_SESSION_ID ||
		getActiveSessionId(projectRoot) ||
		`cli-${randomUUID()}`;

	if (isDebugMode()) {
		console.error(
			`${colors.dim}[generateCliPayload]${colors.reset} sessionId=${sessionId} (source: ${process.env.HAN_SESSION_ID ? "HAN_SESSION_ID" : process.env.CLAUDE_SESSION_ID ? "CLAUDE_SESSION_ID" : "db/generated"})`,
		);
	}

	return {
		session_id: sessionId,
		transcript_path: "", // No transcript in CLI mode
		cwd: projectRoot,
		permission_mode: "default",
		hook_event_name: eventType,
	};
}

/**
 * A discovered hook task ready for execution
 */
interface HookTask {
	plugin: string;
	pluginRoot: string;
	hookName: string;
	hookDef: PluginHookDefinition;
	directories: string[];
	dependsOn: Array<{ plugin: string; hook: string; optional?: boolean }>;
}

/**
 * Result of executing a hook in a directory
 */
interface HookResult {
	plugin: string;
	hook: string;
	directory: string;
	success: boolean;
	output?: string;
	error?: string;
	duration: number;
	skipped?: boolean;
	skipReason?: string;
	/** Hook was deferred to background execution */
	deferred?: boolean;
}

/**
 * Read stdin payload from Claude Code.
 * Handles various stdin types: files, FIFOs, pipes, and sockets.
 */
function readStdinPayload(): HookPayload | null {
	try {
		// TTY means interactive terminal - no piped input
		if (process.stdin.isTTY) {
			return null;
		}

		const { fstatSync } = require("node:fs");
		const stat = fstatSync(0);

		// Accept any non-TTY stdin type (file, FIFO, socket, pipe)
		if (!stat.isFile() && !stat.isFIFO() && !stat.isSocket()) {
			return null;
		}

		// For files, check if there's content before reading
		if (stat.isFile() && stat.size === 0) {
			return null;
		}

		const stdin = readFileSync(0, "utf-8");
		if (stdin.trim()) {
			return JSON.parse(stdin) as HookPayload;
		}
	} catch {
		// stdin not available
	}
	return null;
}

/**
 * Find plugin directory in a marketplace
 */
function findPluginInMarketplace(
	marketplaceRoot: string,
	pluginName: string,
): string | null {
	// Build potential paths - core is a special case since it's not in a subdirectory
	const potentialPaths = [
		join(marketplaceRoot, "jutsu", pluginName),
		join(marketplaceRoot, "do", pluginName),
		join(marketplaceRoot, "hashi", pluginName),
		join(marketplaceRoot, pluginName),
	];

	// Only add core path if we're actually looking for the core plugin
	if (pluginName === "core") {
		potentialPaths.push(join(marketplaceRoot, "core"));
	}

	for (const path of potentialPaths) {
		if (existsSync(path)) {
			return path;
		}
	}
	return null;
}

/**
 * Get plugin directory for a plugin
 */
function getPluginDir(
	pluginName: string,
	marketplace: string,
	marketplaceConfig: MarketplaceConfig | undefined,
): string | null {
	// Check marketplace config for directory source
	if (marketplaceConfig?.source?.source === "directory") {
		const directoryPath = marketplaceConfig.source.path;
		if (directoryPath) {
			const projectDir = getProjectDir();
			const absolutePath = directoryPath.startsWith("/")
				? directoryPath
				: join(projectDir, directoryPath);
			const found = findPluginInMarketplace(absolutePath, pluginName);
			if (found) return found;
		}
	}

	// Check if we're in the marketplace repo (development)
	const projectDir = getProjectDir();
	if (existsSync(join(projectDir, ".claude-plugin", "marketplace.json"))) {
		const found = findPluginInMarketplace(projectDir, pluginName);
		if (found) return found;
	}

	// Fall back to default shared config path
	const configDir = getClaudeConfigDir();
	if (!configDir) return null;

	const marketplaceRoot = join(
		configDir,
		"plugins",
		"marketplaces",
		marketplace,
	);
	if (!existsSync(marketplaceRoot)) return null;

	return findPluginInMarketplace(marketplaceRoot, pluginName);
}

/**
 * Discover all hook tasks for a given event type
 */
function discoverHookTasks(
	eventType: string,
	payload: HookPayload | null,
	projectRoot: string,
): HookTask[] {
	const tasks: HookTask[] = [];
	const { plugins, marketplaces } = getMergedPluginsAndMarketplaces();

	for (const [pluginName, marketplace] of plugins.entries()) {
		const marketplaceConfig = marketplaces.get(marketplace);
		const pluginRoot = getPluginDir(pluginName, marketplace, marketplaceConfig);

		if (!pluginRoot) continue;

		const config = loadPluginConfig(pluginRoot, false);
		if (!config?.hooks) continue;

		for (const [hookName, hookDef] of Object.entries(config.hooks)) {
			// Check if this hook responds to this event type
			if (!hookMatchesEvent(hookDef, eventType)) {
				continue;
			}

			// For PreToolUse/PostToolUse, check tool filter
			if (
				(eventType === "PreToolUse" || eventType === "PostToolUse") &&
				hookDef.toolFilter &&
				hookDef.toolFilter.length > 0
			) {
				const toolName = payload?.tool_name;
				if (!toolName || !hookDef.toolFilter.includes(toolName)) {
					continue;
				}
			}

			// Find directories for this hook
			let directories: string[];
			if (!hookDef.dirsWith || hookDef.dirsWith.length === 0) {
				directories = [projectRoot];
			} else {
				directories = findDirectoriesWithMarkers(projectRoot, hookDef.dirsWith);

				// Apply dirTest filter if specified
				const dirTestCmd = hookDef.dirTest;
				if (dirTestCmd) {
					directories = directories.filter((dir) => {
						try {
							execSync(dirTestCmd, {
								cwd: dir,
								stdio: ["ignore", "ignore", "ignore"],
								encoding: "utf8",
								shell: "/bin/sh",
							});
							return true;
						} catch {
							return false;
						}
					});
				}
			}

			if (directories.length === 0) continue;

			tasks.push({
				plugin: pluginName,
				pluginRoot,
				hookName,
				hookDef,
				directories,
				dependsOn: hookDef.dependsOn || [],
			});
		}
	}

	return tasks;
}

/**
 * Topological sort of hook tasks based on dependencies
 * Returns batches that can be executed in parallel
 */
function resolveDependencies(tasks: HookTask[]): HookTask[][] {
	const taskMap = new Map<string, HookTask>();
	const inDegree = new Map<string, number>();
	const graph = new Map<string, string[]>();

	// Build task lookup and initialize in-degrees
	for (const task of tasks) {
		const key = `${task.plugin}/${task.hookName}`;
		taskMap.set(key, task);
		inDegree.set(key, 0);
		graph.set(key, []);
	}

	// Build dependency graph
	for (const task of tasks) {
		const key = `${task.plugin}/${task.hookName}`;
		for (const dep of task.dependsOn) {
			// Handle wildcard dependencies: { plugin: "*", hook: "*" }
			if (dep.plugin === "*" || dep.hook === "*") {
				// Match all tasks except self
				for (const [depKey, depTask] of taskMap.entries()) {
					if (depKey === key) continue; // Don't depend on self

					// Check if pattern matches
					const matches =
						(dep.plugin === "*" || depTask.plugin === dep.plugin) &&
						(dep.hook === "*" || depTask.hookName === dep.hook);

					if (matches) {
						// Wildcard dependencies are implicitly optional
						if (!taskMap.has(depKey)) continue;
						// Add edge: depTask -> task (depTask must run before task)
						const edges = graph.get(depKey) || [];
						edges.push(key);
						graph.set(depKey, edges);

						// Increment in-degree
						inDegree.set(key, (inDegree.get(key) || 0) + 1);
					}
				}
				continue;
			}

			// Regular dependency (no wildcard)
			const depKey = `${dep.plugin}/${dep.hook}`;

			// Check if dependency exists
			if (!taskMap.has(depKey)) {
				if (dep.optional) {
					continue; // Skip optional missing dependencies
				}
				console.error(
					`Error: Hook ${key} depends on ${depKey}, but it's not available for this event type.`,
				);
				continue;
			}

			// Add edge: dep -> task (dep must run before task)
			const edges = graph.get(depKey) || [];
			edges.push(key);
			graph.set(depKey, edges);

			// Increment in-degree
			inDegree.set(key, (inDegree.get(key) || 0) + 1);
		}
	}

	// Kahn's algorithm for topological sort into batches
	const batches: HookTask[][] = [];
	const remaining = new Set(taskMap.keys());

	while (remaining.size > 0) {
		// Find all tasks with no remaining dependencies
		const batch: HookTask[] = [];
		const toRemove: string[] = [];

		for (const key of remaining) {
			if ((inDegree.get(key) || 0) === 0) {
				const task = taskMap.get(key);
				if (task) {
					batch.push(task);
					toRemove.push(key);
				}
			}
		}

		if (batch.length === 0) {
			// Circular dependency detected
			console.error("Error: Circular dependency detected in hooks:");
			for (const key of remaining) {
				console.error(`  - ${key}`);
			}
			break;
		}

		batches.push(batch);

		// Remove processed tasks and update in-degrees
		for (const key of toRemove) {
			remaining.delete(key);
			for (const dependent of graph.get(key) || []) {
				inDegree.set(dependent, (inDegree.get(dependent) || 0) - 1);
			}
		}
	}

	return batches;
}

/**
 * Execute a single hook in a directory
 */
async function executeHookInDirectory(
	task: HookTask,
	directory: string,
	projectRoot: string,
	payload: HookPayload,
	options: {
		onlyChanged: boolean;
		verbose: boolean;
		cliMode: boolean;
		sessionId: string;
		orchestrationId: string;
		hookType: string;
		isStopHook: boolean;
		logPath: string;
	},
): Promise<HookResult> {
	const startTime = Date.now();
	const relativePath =
		directory === projectRoot ? "." : directory.replace(`${projectRoot}/`, "");

	// Helper for CLI mode verbose output (always logs to file, optionally to console)
	const cliLog = (message: string, color: keyof typeof colors = "reset") => {
		const time = new Date().toLocaleTimeString();
		// Always log to file (without colors)
		appendToOrchestrationLog(options.logPath, `[${time}] ${message}\n`);
		// Log to console if in CLI mode
		if (options.cliMode) {
			console.error(
				`${colors.dim}[${time}]${colors.reset} ${colors[color]}${message}${colors.reset}`,
			);
		}
	};

	// Helper to log detailed output to file only
	const logToFile = (content: string) => {
		appendToOrchestrationLog(options.logPath, content);
	};

	// Check user overrides for enabled state
	const hookSettings = getPluginHookSettings(
		task.plugin,
		task.hookName,
		directory,
	);
	if (hookSettings?.enabled === false) {
		const duration = Date.now() - startTime;
		// Log skipped hook
		const logger = getOrCreateEventLogger();
		logger?.logHookResult(
			task.plugin,
			task.hookName,
			options.hookType,
			relativePath,
			false,
			duration,
			0,
			true,
			"[skipped: disabled by user config]",
			undefined, // error
			undefined, // hookRunId
			task.hookDef.ifChanged,
			task.hookDef.command,
		);
		return {
			plugin: task.plugin,
			hook: task.hookName,
			directory: relativePath,
			success: true,
			skipped: true,
			skipReason: "disabled by user config",
			duration,
		};
	}

	// Check cache if only checking changed files
	if (
		options.onlyChanged &&
		task.hookDef.ifChanged &&
		task.hookDef.ifChanged.length > 0
	) {
		const cacheKey = getCacheKeyForDirectory(
			task.hookName,
			directory,
			projectRoot,
		);
		const hasChanges = await checkForChangesAsync(
			task.plugin,
			cacheKey,
			directory,
			task.hookDef.ifChanged,
			task.pluginRoot,
			{
				sessionId: options.sessionId,
				directory: relativePath,
			},
		);

		if (!hasChanges) {
			const duration = Date.now() - startTime;
			// Log cached skip
			const logger = getOrCreateEventLogger();
			logger?.logHookResult(
				task.plugin,
				task.hookName,
				options.hookType,
				relativePath,
				true, // cached
				duration,
				0,
				true,
				"[skipped: no changes detected]",
				undefined, // error
				undefined, // hookRunId
				task.hookDef.ifChanged,
				task.hookDef.command,
			);
			return {
				plugin: task.plugin,
				hook: task.hookName,
				directory: relativePath,
				success: true,
				skipped: true,
				skipReason: "no changes detected",
				duration,
			};
		}
	}

	// Get resolved command (with user overrides)
	// Also resolve 'han ' prefix to use the current binary for inner commands
	const rawCommand = hookSettings?.command || task.hookDef.command;
	const command = resolveHanCommand(rawCommand);

	// For Stop hooks: acquire a slot and wait for it (no timeout)
	// Wait mode is fully synchronous - no background deferral
	let slotHandle: Awaited<ReturnType<typeof acquireGlobalSlot>> | null = null;
	if (options.isStopHook) {
		// Acquire slot and wait indefinitely
		slotHandle = await acquireGlobalSlot(
			options.sessionId,
			task.hookName,
			task.plugin,
			0, // No timeout - wait indefinitely
		);
	}

	// Log hook_run event and capture UUID for correlation with result
	// Include ifChanged patterns and command to enable per-file validation tracking
	const logger = getOrCreateEventLogger();
	const hookRunId = logger?.logHookRun(
		task.plugin,
		task.hookName,
		options.hookType,
		relativePath,
		false,
		task.hookDef.ifChanged,
		command,
	);
	cliLog(
		`ü™ù hook_run: ${task.plugin}/${task.hookName} in ${relativePath}`,
		"cyan",
	);
	// Log the command to file for debugging
	logToFile(`  Command: ${command}\n`);

	if (options.verbose) {
		console.log(
			`\n[${task.plugin}/${task.hookName}] Running in ${relativePath}:`,
		);
		console.log(`  $ ${command}\n`);
	}

	// Serialize payload to pass via stdin to child process
	const payloadJson = JSON.stringify(payload);
	const hookEnv = {
		CLAUDE_PLUGIN_ROOT: task.pluginRoot,
		CLAUDE_PROJECT_DIR: projectRoot,
		HAN_SESSION_ID: options.sessionId,
	};

	// For Stop hooks: Wait mode is fully synchronous - run command and wait for completion
	// Log output in real-time for visibility
	if (options.isStopHook) {
		const result = await runCommandSync(
			command,
			directory,
			hookEnv,
			payloadJson,
		);

		// Release slot after hook completes
		if (slotHandle) {
			await slotHandle.release();
			slotHandle = null;
		}

		// Process result
		if (result.success) {
			// Always update cache on success (for next run with --only-changed)
			if (task.hookDef.ifChanged && task.hookDef.ifChanged.length > 0) {
				const cacheKey = getCacheKeyForDirectory(
					task.hookName,
					directory,
					projectRoot,
				);
				const commandHash = createHash("sha256").update(command).digest("hex");
				await trackFilesAsync(
					task.plugin,
					cacheKey,
					directory,
					task.hookDef.ifChanged,
					task.pluginRoot,
					{
						logger: logger ?? undefined,
						directory: relativePath,
						commandHash,
						sessionId: options.sessionId,
					},
				);
			}

			logger?.logHookResult(
				task.plugin,
				task.hookName,
				options.hookType,
				relativePath,
				false,
				result.duration,
				0,
				true,
				result.output.trim(),
				undefined,
				hookRunId,
				task.hookDef.ifChanged,
				command,
			);
			cliLog(
				`‚úÖ hook_result: ${task.plugin}/${task.hookName} passed in ${relativePath} (${formatDuration(result.duration)})`,
				"green",
			);
			// Log output to file
			if (result.output.trim()) {
				logToFile(
					`  Output:\n${result.output
						.trim()
						.split("\n")
						.map((l) => `    ${l}`)
						.join("\n")}\n`,
				);
			}

			return {
				plugin: task.plugin,
				hook: task.hookName,
				directory: relativePath,
				success: true,
				output: result.output.trim(),
				duration: result.duration,
			};
		}

		// Hook completed but failed
		logger?.logHookResult(
			task.plugin,
			task.hookName,
			options.hookType,
			relativePath,
			false,
			result.duration,
			result.exitCode,
			false,
			result.output.trim(),
			result.error.trim(),
			hookRunId,
			task.hookDef.ifChanged,
			command,
		);
		cliLog(
			`‚ùå hook_result: ${task.plugin}/${task.hookName} failed in ${relativePath} (${formatDuration(result.duration)})`,
			"red",
		);
		// Log output/error to file
		if (result.output.trim()) {
			logToFile(
				`  Output:\n${result.output
					.trim()
					.split("\n")
					.map((l) => `    ${l}`)
					.join("\n")}\n`,
			);
		}
		if (result.error.trim()) {
			logToFile(
				`  Error:\n${result.error
					.trim()
					.split("\n")
					.map((l) => `    ${l}`)
					.join("\n")}\n`,
			);
		}

		return {
			plugin: task.plugin,
			hook: task.hookName,
			directory: relativePath,
			success: false,
			output: result.output.trim(),
			error: result.error.trim(),
			duration: result.duration,
		};
	}

	// For non-Stop hooks: Use synchronous execution (blocking is fine)
	try {
		const output = execSync(command, {
			cwd: directory,
			encoding: "utf-8",
			timeout: 300000, // 5 minute timeout
			input: payloadJson,
			shell: "/bin/bash",
			env: {
				...process.env,
				...hookEnv,
			},
		});

		// Always update cache on success (for next run with --only-changed)
		if (task.hookDef.ifChanged && task.hookDef.ifChanged.length > 0) {
			const cacheKey = getCacheKeyForDirectory(
				task.hookName,
				directory,
				projectRoot,
			);
			const commandHash = createHash("sha256").update(command).digest("hex");
			await trackFilesAsync(
				task.plugin,
				cacheKey,
				directory,
				task.hookDef.ifChanged,
				task.pluginRoot,
				{
					logger: logger ?? undefined,
					directory: relativePath,
					commandHash,
					sessionId: options.sessionId,
				},
			);
		}

		const duration = Date.now() - startTime;

		logger?.logHookResult(
			task.plugin,
			task.hookName,
			options.hookType,
			relativePath,
			false,
			duration,
			0,
			true,
			output.trim(),
			undefined,
			hookRunId,
			task.hookDef.ifChanged,
			command,
		);
		cliLog(
			`‚úÖ hook_result: ${task.plugin}/${task.hookName} passed in ${relativePath} (${formatDuration(duration)})`,
			"green",
		);
		// Log output to file
		if (output.trim()) {
			logToFile(
				`  Output:\n${output
					.trim()
					.split("\n")
					.map((l) => `    ${l}`)
					.join("\n")}\n`,
			);
		}

		return {
			plugin: task.plugin,
			hook: task.hookName,
			directory: relativePath,
			success: true,
			output: output.trim(),
			duration,
		};
	} catch (error: unknown) {
		const stderr = (error as { stderr?: Buffer })?.stderr?.toString() || "";
		const stdout = (error as { stdout?: Buffer })?.stdout?.toString() || "";
		const exitCode = (error as { status?: number })?.status ?? 1;
		const duration = Date.now() - startTime;

		logger?.logHookResult(
			task.plugin,
			task.hookName,
			options.hookType,
			relativePath,
			false,
			duration,
			exitCode,
			false,
			stdout.trim(),
			stderr.trim(),
			hookRunId,
			task.hookDef.ifChanged,
			command,
		);
		cliLog(
			`‚ùå hook_result: ${task.plugin}/${task.hookName} failed in ${relativePath} (${formatDuration(duration)})`,
			"red",
		);
		// Log output/error to file
		if (stdout.trim()) {
			logToFile(
				`  Output:\n${stdout
					.trim()
					.split("\n")
					.map((l) => `    ${l}`)
					.join("\n")}\n`,
			);
		}
		if (stderr.trim()) {
			logToFile(
				`  Error:\n${stderr
					.trim()
					.split("\n")
					.map((l) => `    ${l}`)
					.join("\n")}\n`,
			);
		}

		return {
			plugin: task.plugin,
			hook: task.hookName,
			directory: relativePath,
			success: false,
			output: stdout.trim(),
			error: stderr.trim(),
			duration,
		};
	} finally {
		if (slotHandle) {
			await slotHandle.release();
		}
	}
}

/**
 * Read the last hook check state from the event log
 * Returns the most recent check state event for the given hook type
 */
/**
 * Check if Stop hook orchestration is currently active.
 * This indicates we're in a recursive scenario where a Stop hook triggered another Stop hook.
 */
function isStopHookActive(): boolean {
	// Check if HAN_STOP_ORCHESTRATING environment variable is set
	// This is set during wait mode execution to prevent recursion
	return process.env.HAN_STOP_ORCHESTRATING === "1";
}

async function getLastHookCheckState(
	sessionId: string,
	hookType: string,
): Promise<{
	fingerprint: string;
	timestamp: string;
	hooks_count: number;
} | null> {
	try {
		// Query the DB for han_events for this session
		const hanEvents = await messages.list({
			sessionId,
			messageType: "han_event",
			limit: 1000, // Get recent events
		});

		// Filter and find most recent hook_check_state for this hook type
		// Events are returned newest first, so we iterate forward
		for (const msg of hanEvents) {
			if (!msg.content) continue;
			try {
				const event = JSON.parse(msg.content);
				if (
					event.type === "hook_check_state" &&
					event.data?.hook_type === hookType
				) {
					return {
						fingerprint: event.data.fingerprint,
						timestamp: event.timestamp || msg.timestamp,
						hooks_count: event.data.hooks_count,
					};
				}
			} catch {
				// Skip invalid JSON
			}
		}
	} catch (_err) {
		// Error querying DB - treat as no previous state
	}

	return null;
}

/**
 * Check mode: Discover hooks and report what would run without executing.
 * This allows the agent to see what validation will happen and explicitly run it.
 *
 * To prevent spamming the same message on every turn, this function tracks the last
 * check state and only outputs if something has changed or enough time has passed.
 */
async function performCheckMode(
	tasks: HookTask[],
	eventType: string,
	projectRoot: string,
	onlyChanged: boolean,
	sessionId: string,
): Promise<void> {
	// Build list of hooks that would run (checking cache/changes)
	const hooksToRun: Array<{
		plugin: string;
		hook: string;
		directory: string;
		reason: string;
	}> = [];
	const hooksSkipped: Array<{
		plugin: string;
		hook: string;
		directory: string;
		reason: string;
	}> = [];

	for (const task of tasks) {
		for (const directory of task.directories) {
			const relativePath =
				directory === projectRoot
					? "."
					: directory.replace(`${projectRoot}/`, "");

			// Check user overrides for enabled state
			const hookSettings = getPluginHookSettings(
				task.plugin,
				task.hookName,
				directory,
			);
			if (hookSettings?.enabled === false) {
				hooksSkipped.push({
					plugin: task.plugin,
					hook: task.hookName,
					directory: relativePath,
					reason: "disabled by user config",
				});
				continue;
			}

			// Check cache if only checking changed files
			if (
				onlyChanged &&
				task.hookDef.ifChanged &&
				task.hookDef.ifChanged.length > 0
			) {
				const cacheKey = getCacheKeyForDirectory(
					task.hookName,
					directory,
					projectRoot,
				);
				const hasChanges = await checkForChangesAsync(
					task.plugin,
					cacheKey,
					directory,
					task.hookDef.ifChanged,
					task.pluginRoot,
					{
						sessionId,
						directory: relativePath,
					},
				);

				if (!hasChanges) {
					hooksSkipped.push({
						plugin: task.plugin,
						hook: task.hookName,
						directory: relativePath,
						reason: "no changes detected (cached)",
					});
					continue;
				}
			}

			// This hook will run
			hooksToRun.push({
				plugin: task.plugin,
				hook: task.hookName,
				directory: relativePath,
				reason: task.hookDef.ifChanged?.length
					? "files changed"
					: "always runs",
			});
		}
	}

	// Compute a fingerprint of the current check state (for deduplication)
	const checkFingerprint = JSON.stringify(
		hooksToRun.map((h) => `${h.plugin}/${h.hook}@${h.directory}`).sort(),
	);

	// Recursion detection: Check if Stop hooks are already active
	// This prevents infinite loops when hooks trigger themselves
	if (
		(eventType === "Stop" || eventType === "SubagentStop") &&
		isStopHookActive() &&
		hooksToRun.length > 0
	) {
		console.error(`
${colors.red}‚ö†Ô∏è  Recursion detected${colors.reset} - Stop hooks are already running, but validation is needed again.

This usually means a hook triggered file changes that need validation.

${colors.bold}Hooks that need to run:${colors.reset}
${hooksToRun.map((h) => `  - ${h.plugin}/${h.hook} in ${h.directory}`).join("\n")}

${colors.cyan}IMPORTANT:${colors.reset} To break the recursion loop:
1. Use the AskUserQuestion tool to ask: "Stop hook recursion detected. Continue with validation?"
2. If user approves, run: ${colors.bold}han hook orchestrate ${eventType} --wait${colors.reset}

${colors.dim}Note: The wait command automatically sets HAN_STOP_ORCHESTRATING=1 to prevent further recursion.${colors.reset}
`);
		process.exit(2);
	}

	// Get the event logger to check/log state
	const logger = getEventLogger();
	let shouldOutput = true;
	const now = Date.now();
	const RECHECK_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes

	if (logger) {
		// Query DB for last check state
		const lastCheckState = await getLastHookCheckState(sessionId, eventType);
		if (lastCheckState) {
			// Only suppress output if:
			// 1. Fingerprint matches (same hooks need validation)
			// 2. Less than 5 minutes have passed
			if (
				lastCheckState.fingerprint === checkFingerprint &&
				now - new Date(lastCheckState.timestamp).getTime() < RECHECK_INTERVAL_MS
			) {
				shouldOutput = false;
			}
		}
	}

	// Output summary
	if (hooksToRun.length === 0) {
		// Log empty check state
		if (logger) {
			logger.logHookCheckState(eventType, "", 0);
		}

		console.error(
			`${colors.green}‚úì No validation needed${colors.reset} - all hooks cached or disabled`,
		);
		if (hooksSkipped.length > 0 && isDebugMode()) {
			console.error(`${colors.dim}Skipped hooks:${colors.reset}`);
			for (const h of hooksSkipped) {
				console.error(
					`  ${colors.dim}- ${h.plugin}/${h.hook} in ${h.directory}: ${h.reason}${colors.reset}`,
				);
			}
		}
		return;
	}

	// Only output if state has changed or enough time has passed
	if (shouldOutput) {
		// Log current check state
		if (logger) {
			logger.logHookCheckState(eventType, checkFingerprint, hooksToRun.length);
		}

		// Create orchestration and queue hooks
		const { orchestrations, pendingHooks } = require("../../db/index.ts");
		const orchestration = orchestrations.create({
			sessionId: sessionId.startsWith("cli-") ? undefined : sessionId,
			hookType: eventType,
			projectRoot,
		});
		const orchestrationId = orchestration.id;

		// Queue each hook for later execution
		for (const h of hooksToRun) {
			// Find the task to get full hook definition
			const task = tasks.find(
				(t) => t.plugin === h.plugin && t.hookName === h.hook,
			);
			if (!task) continue;

			// Get directory path
			const directory =
				h.directory === "." ? projectRoot : `${projectRoot}/${h.directory}`;

			// Build command
			const command = resolveHanCommand(task.hookDef.command);

			// Queue the hook
			pendingHooks.queue({
				orchestrationId,
				plugin: h.plugin,
				hookName: h.hook,
				directory,
				ifChanged: task.hookDef.ifChanged
					? JSON.stringify(task.hookDef.ifChanged)
					: undefined,
				command,
			});
		}

		// Report hooks that need to run
		console.error(
			`${colors.yellow}Validation required${colors.reset} - ${hooksToRun.length} hook(s) need to run:`,
		);
		for (const h of hooksToRun) {
			console.error(
				`  - ${h.plugin}/${h.hook} in ${h.directory} (${h.reason})`,
			);
		}

		if (hooksSkipped.length > 0) {
			console.error(
				`${colors.dim}(${hooksSkipped.length} hook(s) skipped - no changes)${colors.reset}`,
			);
		}

		// Tell agent to run the queued hooks with orchestration ID
		console.error(`
${colors.cyan}To run validation, execute:${colors.reset}
  ${colors.bold}han hook orchestrate ${eventType} --wait --orchestration-id=${orchestrationId}${colors.reset}

${colors.dim}The wait command automatically prevents recursion during execution.${colors.reset}`);

		// Exit with code 2 to indicate action needed (same as validation failures)
		process.exit(2);
	}

	// State unchanged - exit silently (no output spam)
	process.exit(0);
}

/**
 * Main orchestration function
 */
async function orchestrate(
	eventType: string,
	options: {
		onlyChanged: boolean;
		verbose: boolean;
		failFast: boolean;
		wait: boolean;
		check: boolean;
		orchestrationId?: string;
	},
): Promise<void> {
	// Recursion prevention: If we're already orchestrating Stop hooks, don't trigger again
	// This prevents infinite loops when user approves Bash commands during Stop execution.
	// BUT: Allow explicit --wait calls through (that's the user-initiated execution command)
	if (
		(eventType === "Stop" || eventType === "SubagentStop") &&
		process.env.HAN_STOP_ORCHESTRATING === "1" &&
		!options.wait
	) {
		if (isDebugMode()) {
			console.error(
				`${colors.dim}[orchestrate]${colors.reset} Skipping ${eventType} - already orchestrating (recursion prevention)`,
			);
		}
		return;
	}

	// Canonicalize projectRoot to match paths from native module (which uses fs::canonicalize)
	// This ensures path comparison works correctly on macOS where /var -> /private/var
	const rawProjectRoot = getProjectDir();
	const projectRoot = existsSync(rawProjectRoot)
		? realpathSync(rawProjectRoot)
		: rawProjectRoot;

	// Read stdin payload or generate CLI payload
	const stdinPayload = readStdinPayload();
	const cliMode = !stdinPayload;

	// Use stdin payload or generate a CLI payload with proper structure
	const payload: HookPayload =
		stdinPayload || generateCliPayload(eventType, projectRoot);

	// Validate event type matches payload (only for real stdin payloads)
	if (
		stdinPayload?.hook_event_name &&
		stdinPayload.hook_event_name !== eventType
	) {
		console.error(
			`Event mismatch: orchestrate called with "${eventType}" ` +
				`but stdin contains "${stdinPayload.hook_event_name}"`,
		);
		process.exit(1);
	}

	// Session ID is always available (from stdin or generated CLI payload)
	// Fallback to generating one if somehow missing (shouldn't happen)
	let sessionId = payload.session_id || `cli-${randomUUID()}`;
	initEventLogger(sessionId, {}, projectRoot);

	// Set HAN_STOP_ORCHESTRATING=1 automatically for wait mode on Stop events
	// This prevents any hooks triggered during execution from recursing
	if (
		options.wait &&
		(eventType === "Stop" || eventType === "SubagentStop") &&
		process.env.HAN_STOP_ORCHESTRATING !== "1"
	) {
		process.env.HAN_STOP_ORCHESTRATING = "1";
		if (isDebugMode()) {
			console.error(
				`${colors.dim}[orchestrate]${colors.reset} Set HAN_STOP_ORCHESTRATING=1 for recursion prevention`,
			);
		}
	}

	if (isDebugMode()) {
		console.error(
			`${colors.dim}[orchestrate]${colors.reset} eventType=${colors.cyan}${eventType}${colors.reset} session_id=${colors.magenta}${sessionId || "(none)"}${colors.reset}`,
		);
	}

	// If orchestration ID provided, load and execute queued hooks instead of discovering
	let tasks: HookTask[];
	if (options.orchestrationId) {
		const { pendingHooks } = require("../../db/index.ts");

		// Get queued hooks
		const queuedHooks = pendingHooks.list(options.orchestrationId);

		if (queuedHooks.length === 0) {
			console.error(
				`${colors.yellow}No queued hooks found for orchestration ${options.orchestrationId}${colors.reset}`,
			);
			return;
		}

		if (isDebugMode()) {
			console.error(
				`${colors.dim}[orchestrate]${colors.reset} Found ${queuedHooks.length} queued hooks for orchestration ${options.orchestrationId}`,
			);
		}

		// Convert queued hooks to HookTask format
		// This is a simplified version since we already have the command and directory
		tasks = queuedHooks.map(
			(qh: import("../../../../han-native").QueuedHook) => {
				return {
					plugin: qh.plugin,
					hookName: qh.hookName,
					hookDef: {
						command: qh.command,
						ifChanged: qh.ifChanged ? JSON.parse(qh.ifChanged) : undefined,
					},
					directories: [qh.directory],
					pluginRoot: projectRoot, // Simplified - may need actual plugin root
					dependsOn: [],
				};
			},
		);

		// Validate that this is a wait command
		if (!options.wait) {
			console.error(
				`${colors.yellow}Warning: orchestration-id requires --wait flag${colors.reset}`,
			);
			options.wait = true;
		}
	} else {
		// Discover all hook tasks for this event
		tasks = discoverHookTasks(eventType, payload, projectRoot);
	}

	if (tasks.length === 0) {
		if (cliMode || options.check) {
			console.error(
				`${colors.yellow}No hooks found for event type "${eventType}"${colors.reset}`,
			);
		}
		return;
	}

	// Check mode: Just report what would run and tell agent to execute
	if (options.check) {
		await performCheckMode(
			tasks,
			eventType,
			projectRoot,
			options.onlyChanged,
			sessionId,
		);
		return;
	}

	// Use provided orchestration ID or create new one
	const { orchestrations } = require("../../db/index.ts");
	let orchestrationId: string;
	if (options.orchestrationId) {
		// Reuse the orchestration created by --check
		orchestrationId = options.orchestrationId;

		// CRITICAL: Load orchestration to get the session ID used during --check
		// This ensures cache writes use the same session ID as cache reads
		const orch = orchestrations.get(orchestrationId);
		if (orch?.sessionId) {
			sessionId = orch.sessionId;
			if (isDebugMode()) {
				console.error(
					`${colors.dim}[orchestrate]${colors.reset} Using session ID from orchestration: ${sessionId}`,
				);
			}
		}
	} else {
		// Create an orchestration record (cancels any existing running orchestration for this session)
		const orchestration = orchestrations.create({
			sessionId: sessionId.startsWith("cli-") ? undefined : sessionId,
			hookType: eventType,
			projectRoot,
		});
		orchestrationId = orchestration.id;
	}

	// Initialize log file for this orchestration
	const logPath = initOrchestrationLog(orchestrationId, eventType, projectRoot);

	if (isDebugMode()) {
		console.error(
			`${colors.dim}[orchestrate]${colors.reset} Created orchestration ${colors.magenta}${orchestrationId}${colors.reset}`,
		);
	}

	// Print orchestration ID so user can run `han hook wait <id>` if needed
	console.error(`[orchestration:${orchestrationId}]`);

	if (isDebugMode()) {
		console.error(
			`${colors.dim}[orchestrate]${colors.reset} Found ${colors.bold}${tasks.length}${colors.reset} hook tasks for ${colors.cyan}${eventType}${colors.reset}`,
		);
	}

	// Resolve dependencies into execution batches
	const batches = resolveDependencies(tasks);

	if (isDebugMode()) {
		console.error(
			`${colors.dim}[orchestrate]${colors.reset} Resolved into ${colors.bold}${batches.length}${colors.reset} batches`,
		);
		for (let i = 0; i < batches.length; i++) {
			const batchHooks = batches[i].map(
				(t) => `${colors.cyan}${t.plugin}/${t.hookName}${colors.reset}`,
			);
			console.error(
				`  ${colors.dim}Batch ${i + 1}:${colors.reset} ${batchHooks.join(", ")}`,
			);
		}
	}

	const allResults: HookResult[] = [];
	const outputs: string[] = [];
	let hasFailures = false;
	let aborted = false; // Abort flag for fail-fast

	// Execute batches sequentially, hooks within batch in parallel
	for (const batch of batches) {
		// Check abort flag before starting a batch
		if (aborted) break;
		// Run before_all for each hook in the batch (if configured)
		for (const task of batch) {
			const hookSettings = getPluginHookSettings(task.plugin, task.hookName);
			if (hookSettings?.before_all) {
				const beforeAllCmd = resolveHanCommand(hookSettings.before_all);
				if (options.verbose) {
					console.log(
						`\n[${task.plugin}/${task.hookName}] Running before_all:`,
					);
					console.log(`  $ ${beforeAllCmd}\n`);
				}
				try {
					execSync(beforeAllCmd, {
						encoding: "utf-8",
						timeout: 60000,
						stdio: options.verbose ? "inherit" : ["pipe", "pipe", "pipe"],
						shell: "/bin/bash",
						cwd: projectRoot,
						env: {
							...process.env,
							CLAUDE_PROJECT_DIR: projectRoot,
							CLAUDE_PLUGIN_ROOT: task.pluginRoot,
						},
					});
				} catch (error: unknown) {
					const stderr =
						(error as { stderr?: Buffer })?.stderr?.toString() || "";
					console.error(
						`\n‚ùå before_all failed for ${task.plugin}/${task.hookName}:\n${stderr}`,
					);
					hasFailures = true;
				}
			}
		}

		// Build list of all task/directory combinations for this batch
		const pendingTasks: Array<{ task: HookTask; directory: string }> = [];
		for (const task of batch) {
			for (const directory of task.directories) {
				pendingTasks.push({ task, directory });
			}
		}

		// Execute tasks sequentially with fail-fast
		const batchResults: HookResult[] = [];
		let taskIndex = 0;

		// Helper to schedule the next task if not aborted
		const scheduleNext = (): Promise<HookResult> | null => {
			if (aborted && options.failFast) return null;
			if (taskIndex >= pendingTasks.length) return null;

			const { task, directory } = pendingTasks[taskIndex++];
			const relativePath =
				directory === projectRoot
					? "."
					: directory.replace(`${projectRoot}/`, "");

			const promise = (async (): Promise<HookResult> => {
				// Double-check abort flag (may have changed while waiting for slot)
				if (aborted && options.failFast) {
					return {
						plugin: task.plugin,
						hook: task.hookName,
						directory: relativePath,
						success: true,
						skipped: true,
						skipReason: "aborted due to earlier failure",
						duration: 0,
					};
				}

				const result = await executeHookInDirectory(
					task,
					directory,
					projectRoot,
					payload,
					{
						...options,
						cliMode,
						sessionId,
						orchestrationId,
						hookType: eventType,
						isStopHook: eventType === "Stop",
						logPath,
					},
				);

				// Set abort flag on failure
				if (!result.success && !result.skipped && options.failFast) {
					aborted = true;
					if (isDebugMode()) {
						console.error(
							`${colors.red}[fail-fast]${colors.reset} Aborting due to failure in ${task.plugin}/${task.hookName}`,
						);
					}
				}

				return result;
			})();

			return promise;
		};

		// Execute tasks sequentially (execSync blocks, so no real parallelism anyway)
		// This ensures fail-fast works correctly - no new tasks start after failure
		while (taskIndex < pendingTasks.length && (!aborted || !options.failFast)) {
			const p = scheduleNext();
			if (!p) break;

			const result = await p;
			batchResults.push(result);
		}

		// Mark remaining tasks as skipped if aborted
		while (taskIndex < pendingTasks.length) {
			const { task, directory } = pendingTasks[taskIndex++];
			const relativePath =
				directory === projectRoot
					? "."
					: directory.replace(`${projectRoot}/`, "");
			batchResults.push({
				plugin: task.plugin,
				hook: task.hookName,
				directory: relativePath,
				success: true,
				skipped: true,
				skipReason: "aborted due to earlier failure",
				duration: 0,
			});
		}
		allResults.push(...batchResults);

		// Check for failures
		const failures = batchResults.filter((r) => !r.success && !r.skipped);
		if (failures.length > 0) {
			hasFailures = true;
			// Fail fast: abort and stop executing remaining batches
			if (options.failFast) {
				aborted = true;
				break;
			}
		}

		// Collect successful outputs
		for (const result of batchResults) {
			if (result.success && result.output && !result.skipped) {
				outputs.push(result.output);
			}
		}
	}

	// Log summary
	const eventLogger = getEventLogger();
	if (eventLogger) {
		const successful = allResults.filter((r) => r.success && !r.skipped).length;
		const skipped = allResults.filter((r) => r.skipped).length;
		const failed = allResults.filter((r) => !r.success).length;

		if (options.verbose) {
			console.log(
				`\nOrchestration complete: ${successful} passed, ${skipped} skipped, ${failed} failed`,
			);
		}

		eventLogger.flush();
	}

	// Output aggregated results
	if (outputs.length > 0) {
		console.log(outputs.join("\n\n"));
	}

	// For Stop hooks only: handle deferred execution and attempt tracking
	if (eventType === "Stop") {
		const deferredHooks = allResults.filter((r) => r.deferred);
		const failedHooks = allResults.filter((r) => !r.success && !r.skipped);
		const isRetryRun = payload.stop_hook_active === true;

		// If this is a retry run, increment attempts for failed hooks and check if stuck
		if (isRetryRun && failedHooks.length > 0) {
			const stuckHooks: Array<{
				plugin: string;
				hookName: string;
				directory: string;
				attempts: number;
				maxAttempts: number;
			}> = [];

			for (const hook of failedHooks) {
				const attemptInfo = hookAttempts.increment(
					sessionId,
					hook.plugin,
					hook.hook,
					hook.directory,
				);

				if (attemptInfo.isStuck) {
					stuckHooks.push({
						plugin: hook.plugin,
						hookName: hook.hook,
						directory: hook.directory,
						attempts: attemptInfo.consecutiveFailures,
						maxAttempts: attemptInfo.maxAttempts,
					});
				}
			}

			// If any hooks are stuck, ask user before continuing
			if (stuckHooks.length > 0) {
				console.error(`The following hooks have failed ${stuckHooks[0].maxAttempts} times:
${stuckHooks.map((h) => `  - ${h.plugin}/${h.hookName} in ${h.directory}`).join("\n")}

üìÑ Full output logged to: ${logPath}

Use AskUserQuestion to ask the user: "Would you like to continue trying to fix these hooks?"
If yes, call mcp__plugin_core_han__increase_max_attempts for each stuck hook:
${stuckHooks.map((h) => `  - session_id: "${sessionId}", plugin: "${h.plugin}", hook_name: "${h.hookName}", directory: "${h.directory}"`).join("\n")}
Then retry fixing the issues.`);
				process.exit(2);
			}
		}

		// If we have deferred hooks (queued for background), handle wait
		if (deferredHooks.length > 0) {
			// Update orchestration with deferred count
			orchestrations.update({
				id: orchestrationId,
				deferredHooks: deferredHooks.length,
			});

			if (options.wait) {
				// Wait inline for deferred hooks
				console.error(`Hooks deferred to background execution:
${deferredHooks.map((h) => `  - ${h.plugin}/${h.hook} (${h.directory})`).join("\n")}

Waiting for hooks to complete...`);
				// Import and call wait logic
				const { waitForOrchestration } = await import("./wait.ts");
				await waitForOrchestration(orchestrationId, {
					pollInterval: 1000,
					timeout: 300000,
				});
				// waitForOrchestration will process.exit() with appropriate code
			} else {
				console.error(`[han hook orchestrate ${eventType}]: [orchestration:${orchestrationId}]
Hooks deferred to background execution:
${deferredHooks.map((h) => `  - ${h.plugin}/${h.hook} (${h.directory})`).join("\n")}

Run \`han hook wait ${orchestrationId}\` to wait for hooks and see their output.
If hooks fail, you will be notified and should fix the issues.`);
				process.exit(2);
			}
		}

		// If we have failed hooks (but not stuck), tell agent to fix them
		if (failedHooks.length > 0) {
			console.error(`
‚ùå Hook validation failed:
${failedHooks.map((h) => `  - ${h.plugin}/${h.hook} in ${h.directory}`).join("\n")}

üìÑ Full output logged to: ${logPath}

Read the log file to see error details, then spawn a subagent to fix the issues.
When done, the Stop hook will run again to verify the fixes.`);
			process.exit(2);
		}

		// All hooks passed - reset attempt counters for any hooks that previously failed
		for (const result of allResults) {
			if (result.success && !result.skipped) {
				hookAttempts.reset(
					sessionId,
					result.plugin,
					result.hook,
					result.directory,
				);
			}
		}

		// Update orchestration as completed
		const completedCount = allResults.filter(
			(r) => r.success && !r.skipped,
		).length;
		orchestrations.update({
			id: orchestrationId,
			status: "completed",
			totalHooks: allResults.length,
			completedHooks: completedCount,
		});

		// Clean up queued hooks if this was a --wait execution
		if (options.orchestrationId) {
			const { pendingHooks } = require("../../db/index.ts");
			const deleted = pendingHooks.delete(options.orchestrationId);
			if (isDebugMode() && deleted > 0) {
				console.error(
					`${colors.dim}[orchestrate]${colors.reset} Deleted ${deleted} queued hooks for orchestration ${options.orchestrationId}`,
				);
			}
		}

		// All hooks passed - allow stop (exit 0)
		return;
	}

	// For non-Stop hooks, original behavior
	if (hasFailures) {
		const failedHooks = allResults.filter((r) => !r.success && !r.skipped);
		console.error(`
‚ùå Hook validation failed:
${failedHooks.map((h) => `  - ${h.plugin}/${h.hook} in ${h.directory}`).join("\n")}

üìÑ Full output logged to: ${logPath}

Read the log file to see error details.`);
		orchestrations.update({
			id: orchestrationId,
			status: "failed",
			totalHooks: allResults.length,
			completedHooks: allResults.filter((r) => r.success && !r.skipped).length,
			failedHooks: failedHooks.length,
		});
		process.exit(2);
	}

	// Mark orchestration as completed
	orchestrations.update({
		id: orchestrationId,
		status: "completed",
		totalHooks: allResults.length,
		completedHooks: allResults.filter((r) => r.success && !r.skipped).length,
	});
}

/**
 * Register the orchestrate command
 */
export function registerHookOrchestrate(hookCommand: Command): void {
	hookCommand
		.command("orchestrate <eventType>")
		.description(
			"Orchestrate all hooks for a given Claude Code event type.\n\n" +
				"This is the central entry point for hook execution. It:\n" +
				"  - Discovers all installed plugins and their hooks\n" +
				"  - Filters hooks by event type (Stop, PreToolUse, etc.)\n" +
				"  - Resolves dependencies between hooks\n" +
				"  - Executes hooks with controlled parallelism\n\n" +
				"Event types: Stop, SubagentStop, PreToolUse, PostToolUse,\n" +
				"             SessionStart, UserPromptSubmit, SubagentStart",
		)
		.option(
			"--all-files",
			"Check all files, not just changed files (ignores cache)",
		)
		.option("--no-fail-fast", "Continue executing even after failures")
		.option("-v, --verbose", "Show detailed execution output")
		.option(
			"-w, --wait",
			"Wait for deferred hooks to complete (tail logs inline)",
		)
		.option(
			"-c, --check",
			"Check mode: report what hooks would run without executing them",
		)
		.option(
			"--orchestration-id <id>",
			"Run queued hooks from a specific orchestration (use with --wait)",
		)
		.action(
			async (
				eventType: string,
				opts: {
					allFiles?: boolean;
					failFast?: boolean;
					verbose?: boolean;
					wait?: boolean;
					check?: boolean;
					orchestrationId?: string;
				},
			) => {
				await orchestrate(eventType, {
					onlyChanged: !opts.allFiles, // default true (only changed files)
					failFast: opts.failFast !== false,
					verbose: opts.verbose ?? false,
					check: opts.check ?? false,
					wait: opts.wait ?? false,
					orchestrationId: opts.orchestrationId,
				});
			},
		);
}
