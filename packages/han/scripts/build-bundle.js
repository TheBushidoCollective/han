#!/usr/bin/env bun
/**
 * Build script for han CLI binary.
 *
 * This script compiles the TypeScript source directly to a standalone binary
 * using `bun build --compile`. The native module (.node file) is embedded
 * automatically when using a bare `require()` with a static string path.
 *
 * Since bun build --compile doesn't support --define, we generate a build-info
 * file that gets imported by the main module.
 *
 * Usage:
 *   bun scripts/build-bundle.js [target]
 *
 * Targets:
 *   - bun (default, current platform)
 *   - bun-darwin-arm64
 *   - bun-darwin-x64
 *   - bun-linux-x64
 *   - bun-linux-arm64
 *   - bun-windows-x64
 */
import {
	copyFileSync,
	existsSync,
	mkdirSync,
	readFileSync,
	writeFileSync,
} from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const packageJson = JSON.parse(
	readFileSync(join(__dirname, "..", "package.json"), "utf-8"),
);

const version = packageJson.version;

// Read the detect-plugins prompt
const detectPluginsPrompt = readFileSync(
	join(__dirname, "..", "lib", "detect-plugins-prompt.md"),
	"utf-8",
);

const target = Bun.argv[2] || "bun";
const isCurrentPlatform = target === "bun";
const outfile = isCurrentPlatform
	? join(__dirname, "..", "dist", "han")
	: join(
			__dirname,
			"..",
			"dist",
			"binaries",
			`han-${target.replace("bun-", "")}`,
		);

console.log(`Building han v${version} for ${target}...`);

// Ensure output directory exists
mkdirSync(dirname(outfile), { recursive: true });

// Map target to platform identifier for native module
// These names must match the workflow matrix native_file values
const platformMap = {
	bun: `${process.platform}-${process.arch}`,
	"bun-darwin-arm64": "darwin-arm64",
	"bun-darwin-x64": "darwin-x64",
	"bun-linux-x64": "linux-x64-gnu",
	"bun-linux-arm64": "linux-arm64-gnu",
	"bun-windows-x64": "win32-x64-msvc",
};

const platform = platformMap[target];
if (!platform) {
	console.error(`Unknown target: ${target}`);
	process.exit(1);
}

// Copy the native module for the target platform
const nativeModuleSrc = join(
	__dirname,
	"..",
	"..",
	"han-native",
	`han-native.${platform}.node`,
);
const nativeModuleDest = join(__dirname, "..", "native", "han-native.node");

if (!existsSync(nativeModuleSrc)) {
	console.error(
		`Native module not found for platform ${platform}: ${nativeModuleSrc}`,
	);
	process.exit(1);
}

mkdirSync(dirname(nativeModuleDest), { recursive: true });
copyFileSync(nativeModuleSrc, nativeModuleDest);
console.log(`Copied native module: ${nativeModuleSrc} -> ${nativeModuleDest}`);

// Generate build-info.ts with version and prompt embedded
const buildInfoPath = join(__dirname, "..", "lib", "build-info.generated.ts");
writeFileSync(
	buildInfoPath,
	`// Auto-generated by build-bundle.js - DO NOT EDIT
export const HAN_VERSION = ${JSON.stringify(version)};
export const DETECT_PLUGINS_PROMPT = ${JSON.stringify(detectPluginsPrompt)};
`,
);

// Compile using bun build --compile
const proc = Bun.spawn(
	[
		"bun",
		"build",
		"--compile",
		"--minify",
		`--target=${target}`,
		join(__dirname, "..", "lib", "main.ts"),
		"--outfile",
		outfile,
	],
	{
		cwd: join(__dirname, ".."),
		stdout: "inherit",
		stderr: "inherit",
	},
);

const exitCode = await proc.exited;
if (exitCode !== 0) {
	console.error("Build failed");
	process.exit(exitCode);
}

console.log(`Built successfully: ${outfile}`);
